<h1>Filtrer par date avec des jointures : rÃ©soudre le problÃ¨me de recouvrement de pÃ©riodes dans Xano</h1>

<p><strong>Comprendre comment crÃ©er des filtres combinÃ©s avec des jointures correctes et une logique de recouvrement de dates pour afficher uniquement les rÃ©sultats rÃ©ellement disponibles.</strong></p>

<!-- Metadata block -->
<div class="metadata">
    <p>ğŸ·ï¸ <strong>CatÃ©gorie:</strong> Xano</p>
    <p>ğŸ¯ <strong>Niveau:</strong> IntermÃ©diaire</p>
    <p>ğŸ” <strong>Mots-clÃ©s:</strong> JOINs, Filtres de dates, Recouvrement de pÃ©riodes, repairer_category_id, Query All Records, Relations multiples, Date overlap, Retool</p>
    <p>ğŸ“… <strong>Mise Ã  jour:</strong> 27/10/2025</p>
    <p>â±ï¸ <strong>Temps passÃ©:</strong> 1-2 heures</p>
    <p>âš™ï¸ <strong>Stack:</strong> Xano + Retool</p>
</div>

<!-- TL;DR -->
<div class="tldr">
âœ… <strong>TL;DR :</strong>
Pour filtrer par dates avec des jointures dans Xano, utilisez la bonne clÃ© de relation (<code>repairer_category_id</code> au lieu de <code>repairer_id</code>) et la logique de recouvrement : <code>session.start_date &lt;= input.end_date && session.end_date &gt;= input.start_date</code>.
</div>

<h2>ğŸ¤” ProblÃ¨me rencontrÃ©</h2>

<p><strong>ğŸ¯ Objectif :</strong> Afficher les rÃ©parateurs disponibles selon 4 filtres combinÃ©s :</p>

<ol>
    <li><strong>CatÃ©gorie</strong> (<code>categorie_name</code>)</li>
    <li><strong>Code postal</strong> (<code>zip</code>)</li>
    <li><strong>Date de dÃ©but</strong> (<code>start_date</code>)</li>
    <li><strong>Date de fin</strong> (<code>end_date</code>)</li>
</ol>

<p><strong>ğŸš¨ Les blocages :</strong></p>

<ul>
    <li>Les sessions Ã©taient liÃ©es via <code>repairer_id</code>, ce qui ne permettait pas de filtrer par catÃ©gorie</li>
    <li>Les dates Ã©taient ignorÃ©es car la jointure n'Ã©tait pas reliÃ©e Ã  la bonne entitÃ©</li>
    <li>Certains tests retournaient <strong>100% de rÃ©sultats</strong>, mÃªme pour des dates hors pÃ©riode</li>
    <li>La relation utilisÃ©e Ã©tait incorrecte : <code>$db.repairer_category.id == $db.session.repairer_id</code></li>
</ul>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
Xano affiche parfois les relations avec des noms lisibles (<code>title</code>, <code>name</code>) au lieu des IDs, ce qui peut induire en erreur. Toujours vÃ©rifier quelle colonne est rÃ©ellement utilisÃ©e dans la jointure !
</div>

<h2>ğŸ” Explication simplifiÃ©e</h2>

<h3>ğŸ“š Analogie : rÃ©server un professionnel</h3>

<p>Imaginons que vous cherchez un Ã©lectricien disponible :</p>

<ul>
    <li><strong>Mauvaise approche</strong> : "Je cherche tous les professionnels qui ont une session quelque part" â†’ vous obtenez des plombiers, des Ã©lectriciens, des menuisiers...</li>
    <li><strong>Bonne approche</strong> : "Je cherche les professionnels <strong>dont la session correspond Ã  la catÃ©gorie Ã©lectricien</strong> et qui sont disponibles aux dates demandÃ©es"</li>
</ul>

<h3>ğŸ”— Comprendre la structure des relations</h3>

<p>Voici la structure de donnÃ©es simplifiÃ©e :</p>

<pre><code>repairer (rÃ©parateur)
  â†“ a plusieurs
repairer_category (catÃ©gories proposÃ©es par le rÃ©parateur)
  â†“ a plusieurs
session (pÃ©riodes de disponibilitÃ© pour UNE catÃ©gorie)
</code></pre>

<p><strong>Exemple concret :</strong></p>

<ul>
    <li><strong>Jean</strong> (repairer) â†’ propose <strong>VÃ©lo</strong> et <strong>Avion</strong> (repairer_category)</li>
    <li>Pour <strong>VÃ©lo</strong> : disponible du 1er au 10 octobre (session 1)</li>
    <li>Pour <strong>Avion</strong> : disponible du 5 au 15 octobre (session 2)</li>
</ul>

<p>Si vous cherchez un rÃ©parateur pour <strong>Avion du 8 au 12 octobre</strong>, vous devez :</p>
<ol>
    <li>Filtrer par catÃ©gorie <strong>Avion</strong></li>
    <li>VÃ©rifier que la session 2 <strong>chevauche</strong> la pÃ©riode demandÃ©e</li>
</ol>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
La clÃ© de la jointure doit Ãªtre <code>repairer_category_id</code> (pas <code>repairer_id</code>) car chaque session est liÃ©e Ã  <strong>une catÃ©gorie spÃ©cifique</strong> du rÃ©parateur, pas au rÃ©parateur lui-mÃªme.
</div>

<h2>âŒ Les erreurs initiales</h2>

<table>
    <thead>
        <tr>
            <th>Jointure erronÃ©e</th>
            <th>Pourquoi Ã§a ne marche pas</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>$db.repairer_category.id == $db.session.repairer_id</code></td>
            <td><strong>Mauvaise relation</strong> : on relie une catÃ©gorie Ã  un rÃ©parateur, au lieu de relier la catÃ©gorie Ã  la session correspondante. RÃ©sultat : impossible de filtrer par catÃ©gorie.</td>
        </tr>
        <tr>
            <td>Pas de jointure du tout</td>
            <td><strong>DonnÃ©es isolÃ©es</strong> : on ne peut pas croiser les informations entre les tables, donc impossible de filtrer par catÃ©gorie ET par dates simultanÃ©ment.</td>
        </tr>
        <tr>
            <td>Filtre simple sur les dates sans logique de recouvrement</td>
            <td><strong>Logique incomplÃ¨te</strong> : vÃ©rifier uniquement <code>start_date</code> ou <code>end_date</code> ne couvre pas tous les cas de chevauchement de pÃ©riodes.</td>
        </tr>
    </tbody>
</table>

<h2>âœ… La solution dÃ©taillÃ©e</h2>

<h3>ğŸ¯ Ã‰tape 1 : Corriger la jointure</h3>

<p><strong>Jointure correcte :</strong></p>

<pre><code>$db.repairer_category.id == $db.session.repairer_category_id</code></pre>

<p><strong>Pourquoi Ã§a fonctionne :</strong></p>
<ul>
    <li><code>session.repairer_category_id</code> est la clÃ© Ã©trangÃ¨re qui pointe vers la catÃ©gorie du rÃ©parateur</li>
    <li>Cela permet de filtrer les sessions en fonction de la catÃ©gorie demandÃ©e</li>
    <li>On accÃ¨de ainsi aux bonnes donnÃ©es : catÃ©gorie â†’ sessions de cette catÃ©gorie</li>
</ul>

<h3>ğŸ“… Ã‰tape 2 : ImplÃ©menter la logique de recouvrement de dates</h3>

<p><strong>Condition de filtrage :</strong></p>

<pre><code>$db.session.start_date <=? $input.end_date
&&
$db.session.end_date >=? $input.start_date</code></pre>

<h3>ğŸ”¬ Pourquoi cette logique fonctionne-t-elle ?</h3>

<p>Cette condition vÃ©rifie que la session <strong>chevauche</strong> (overlap) la pÃ©riode demandÃ©e. Voici les cas couverts :</p>

<table>
    <thead>
        <tr>
            <th>ScÃ©nario</th>
            <th>Session</th>
            <th>Recherche</th>
            <th>RÃ©sultat</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>âœ… Session complÃ¨tement dans la pÃ©riode</td>
            <td>5 au 10 oct</td>
            <td>1 au 15 oct</td>
            <td>Inclus</td>
        </tr>
        <tr>
            <td>âœ… Session englobe la pÃ©riode</td>
            <td>1 au 20 oct</td>
            <td>5 au 10 oct</td>
            <td>Inclus</td>
        </tr>
        <tr>
            <td>âœ… Chevauchement partiel dÃ©but</td>
            <td>1 au 8 oct</td>
            <td>5 au 15 oct</td>
            <td>Inclus</td>
        </tr>
        <tr>
            <td>âœ… Chevauchement partiel fin</td>
            <td>12 au 20 oct</td>
            <td>5 au 15 oct</td>
            <td>Inclus</td>
        </tr>
        <tr>
            <td>âŒ Session avant la pÃ©riode</td>
            <td>1 au 3 oct</td>
            <td>5 au 15 oct</td>
            <td>Exclu</td>
        </tr>
        <tr>
            <td>âŒ Session aprÃ¨s la pÃ©riode</td>
            <td>20 au 30 oct</td>
            <td>5 au 15 oct</td>
            <td>Exclu</td>
        </tr>
    </tbody>
</table>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
La logique de recouvrement peut sembler contre-intuitive, mais souvenez-vous : <strong>start &lt;= end</strong> ET <strong>end &gt;= start</strong>. C'est la formule universelle pour vÃ©rifier qu'il y a chevauchement entre deux pÃ©riodes !
</div>

<h3>ğŸ› ï¸ Ã‰tape 3 : RequÃªte Xano complÃ¨te</h3>

<p><strong>Configuration dans Query All Records :</strong></p>

<pre><code>{
  "table": "session",
  "where": {
    "and": [
      {
        "expression": "$db.session.start_date <=? $input.end_date"
      },
      {
        "expression": "$db.session.end_date >=? $input.start_date"
      },
      {
        "join": "$db.repairer_category.id == $db.session.repairer_category_id"
      }
    ]
  }
}</code></pre>

<p><strong>Avec les autres filtres (catÃ©gorie, code postal) :</strong></p>

<pre><code>{
  "table": "session",
  "where": {
    "and": [
      {
        "expression": "$db.session.start_date <=? $input.end_date"
      },
      {
        "expression": "$db.session.end_date >=? $input.start_date"
      },
      {
        "join": "$db.repairer_category.id == $db.session.repairer_category_id"
      },
      {
        "expression": "$db.repairer_category.name ==? $input.categorie_name"
      },
      {
        "expression": "$db.repairer.zip ==? $input.zip"
      }
    ]
  }
}</code></pre>

<h2>ğŸ§° Exemple concret de requÃªte test</h2>

<h3>ğŸ“Š DonnÃ©es d'entrÃ©e (input)</h3>

<pre><code>{
  "zip": "51114",
  "start_date": "2025-10-02T00:00:00.000Z",
  "end_date": "2025-10-23T23:59:59.000Z",
  "categorie_name": "Avion"
}</code></pre>

<h3>âœ… RÃ©sultat attendu</h3>

<p>La requÃªte retourne les rÃ©parateurs qui :</p>
<ul>
    <li>âœ… Sont dans le code postal <strong>51114</strong></li>
    <li>âœ… Proposent la catÃ©gorie <strong>Avion</strong></li>
    <li>âœ… Ont une session disponible <strong>entre le 2 et le 23 octobre 2025</strong></li>
</ul>

<h3>ğŸ“‹ Structure des donnÃ©es retournÃ©es</h3>

<pre><code>[
  {
    "repairer": {
      "id": 123,
      "name": "Jean Martin",
      "zip": "51114"
    },
    "category": {
      "id": 45,
      "name": "Avion"
    },
    "session": {
      "id": 789,
      "start_date": "2025-10-05T00:00:00.000Z",
      "end_date": "2025-10-20T23:59:59.000Z",
      "repairer_category_id": 45
    }
  }
]</code></pre>

<div class="callout callout-advanced">
ğŸ”¬ <strong>Pour aller plus loin</strong><br>
Pour optimiser les performances, crÃ©ez des <strong>index</strong> sur les colonnes utilisÃ©es dans les filtres : <code>start_date</code>, <code>end_date</code>, <code>repairer_category_id</code>, et <code>zip</code>. Cela accÃ©lÃ©rera considÃ©rablement les requÃªtes avec de gros volumes de donnÃ©es.
</div>

<h2>ğŸ§ª Cas de test pour valider la logique</h2>

<p>Testez votre requÃªte avec ces scÃ©narios pour vous assurer qu'elle fonctionne correctement :</p>

<table>
    <thead>
        <tr>
            <th>Cas de test</th>
            <th>Input dates</th>
            <th>Session dates</th>
            <th>Attendu</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Session exactement dans la pÃ©riode</td>
            <td>1 au 10 oct</td>
            <td>3 au 8 oct</td>
            <td>âœ… Inclus</td>
        </tr>
        <tr>
            <td>Session englobe la pÃ©riode</td>
            <td>5 au 10 oct</td>
            <td>1 au 15 oct</td>
            <td>âœ… Inclus</td>
        </tr>
        <tr>
            <td>Chevauchement dÃ©but</td>
            <td>5 au 15 oct</td>
            <td>1 au 8 oct</td>
            <td>âœ… Inclus</td>
        </tr>
        <tr>
            <td>Chevauchement fin</td>
            <td>5 au 15 oct</td>
            <td>12 au 20 oct</td>
            <td>âœ… Inclus</td>
        </tr>
        <tr>
            <td>Dates exactement identiques</td>
            <td>5 au 10 oct</td>
            <td>5 au 10 oct</td>
            <td>âœ… Inclus</td>
        </tr>
        <tr>
            <td>Session complÃ¨tement avant</td>
            <td>10 au 20 oct</td>
            <td>1 au 5 oct</td>
            <td>âŒ Exclu</td>
        </tr>
        <tr>
            <td>Session complÃ¨tement aprÃ¨s</td>
            <td>1 au 10 oct</td>
            <td>15 au 20 oct</td>
            <td>âŒ Exclu</td>
        </tr>
    </tbody>
</table>

<div class="callout callout-tip">
âœ¨ <strong>Astuce de test</strong><br>
Utilisez l'onglet "Test & Preview" de Xano pour tester ces diffÃ©rents cas. CrÃ©ez plusieurs sessions avec des dates variÃ©es pour valider que seuls les bons rÃ©sultats sont retournÃ©s.
</div>

<h2>ğŸ“Œ Ã€ retenir</h2>

<div class="summary">
ğŸ“Œ <strong>Ã€ retenir :</strong>
<ul>
  <li><strong>Utiliser la bonne clÃ© de relation</strong> : <code>repairer_category_id</code> (pas <code>repairer_id</code>) car chaque session est liÃ©e Ã  une catÃ©gorie spÃ©cifique</li>
  <li><strong>Logique de recouvrement</strong> : <code>start_date &lt;= input.end_date && end_date &gt;= input.start_date</code> couvre tous les cas de chevauchement</li>
  <li><strong>Tester avec des cas limites</strong> : dates identiques, chevauchements partiels, pÃ©riodes complÃ¨tement en dehors</li>
  <li><strong>Optimiser avec des index</strong> sur les colonnes de dates pour de meilleures performances</li>
</ul>
</div>

<h2>ğŸ”— Liens utiles</h2>

<ul>
    <li><a href="https://docs.xano.com/working-with-your-database/queries/filtering-your-results" target="_blank">Documentation Xano : Filtrer les rÃ©sultats</a></li>
    <li><a href="https://docs.xano.com/working-with-your-database/queries/joins-and-relationships" target="_blank">Documentation Xano : Jointures et relations</a></li>
    <li>Article connexe dans cette base : <em>Pourquoi mon API Xano retourne toujours les mÃªmes donnÃ©es ?</em></li>
    <li>Article connexe : <em>IntÃ©gration Xano + WeWeb : Afficher dynamiquement les catÃ©gories</em></li>
</ul>

<h2>ğŸ§  Quiz rapide</h2>

<p><strong>Question :</strong> Pourquoi utilise-t-on <code>start_date &lt;= input.end_date</code> ET <code>end_date &gt;= input.start_date</code> plutÃ´t qu'une simple comparaison ?</p>

<details>
    <summary>âœ… Voir la rÃ©ponse</summary>
    <p><strong>RÃ©ponse :</strong></p>
    <p>Cette double condition permet de capturer <strong>tous les types de chevauchement</strong> :</p>
    <ul>
        <li><code>start_date &lt;= input.end_date</code> â†’ la session commence avant ou pendant la fin de recherche</li>
        <li><code>end_date &gt;= input.start_date</code> â†’ la session se termine aprÃ¨s ou pendant le dÃ©but de recherche</li>
    </ul>
    <p>Si les deux conditions sont vraies, il y a forcÃ©ment un chevauchement ! Une seule condition ne suffirait pas Ã  couvrir tous les scÃ©narios (chevauchement partiel dÃ©but/fin, session englobante, etc.).</p>
</details>
