<h1>Xano : Filtrer des sessions par date (m√™me jour) en ignorant l'heure ‚Äî Mission impossible ?</h1>

<!-- Metadata block -->
<div class="metadata">
    <p>üè∑Ô∏è <strong>Cat√©gorie:</strong> Xano</p>
    <p>üéØ <strong>Niveau:</strong> Avanc√©</p>
    <p>üîç <strong>Mots-cl√©s:</strong> Query Builder, Timestamps, Filtres, format_timestamp, WHERE clause, Limitations Xano, Debugging</p>
    <p>üìÖ <strong>Mise √† jour:</strong> 19/11/2025</p>
    <p>‚è±Ô∏è <strong>Temps pass√©:</strong> 3h30</p>
    <p>‚öôÔ∏è <strong>Stack:</strong> WeWeb + Xano</p>
</div>

<!-- TL;DR -->
<div class="tldr">
‚úÖ <strong>TL;DR :</strong>
Comparer uniquement le <strong>jour</strong> de deux timestamps (en ignorant l'heure) est trivial en SQL. Mais dans Xano, c'est un enfer : le Query Builder refuse <code>format_timestamp()</code> dans les WHERE, ne permet pas de parser ou convertir correctement les timestamps, et n'offre aucune visibilit√© sur le SQL g√©n√©r√©. Cet article d√©cortique TOUTES les approches tent√©es et explique pourquoi le Query Builder de Xano est inadapt√© pour cette op√©ration basique.
</div>

<h2>ü§î Le besoin (apparemment) trivial</h2>

<p>Tu veux faire quelque chose de <strong>parfaitement banal</strong> :</p>

<blockquote>
R√©cup√©rer toutes les sessions dont <code>session.start_date</code> est <strong>le m√™me jour</strong> que <code>input.date_debut</code>, <strong>sans tenir compte de l'heure</strong>.
</blockquote>

<p><strong>Exemple concret :</strong></p>

<ul>
    <li>Input WeWeb : <code>date_debut: 1763578800000</code> (timestamp en millisecondes = 19 novembre 2025, 00:00:00)</li>
    <li>Session en base : <code>start_date: 2025-11-19 14:30:00</code></li>
    <li><strong>R√©sultat attendu :</strong> Cette session doit √™tre retourn√©e car <code>19/11/2025 == 19/11/2025</code></li>
</ul>

<p>En SQL natif, ce serait :</p>

<pre><code>SELECT *
FROM session
WHERE DATE(start_date) = DATE(FROM_UNIXTIME(:date_debut / 1000))
</code></pre>

<p><strong>SIMPLE. √âVIDENT. UNIVERSEL.</strong></p>

<p>Sauf que dans Xano... c'est une autre histoire.</p>

<h2>üîç Les 7 approches tent√©es (toutes bloqu√©es)</h2>

<h3>1Ô∏è‚É£ Utiliser <code>format_timestamp()</code> dans le WHERE</h3>

<p><strong>Id√©e :</strong></p>

<pre><code>format_timestamp(db.session.start_date, "Y-m-d") == format_timestamp(input.date_debut, "Y-m-d")
</code></pre>

<p><strong>R√©sultat :</strong></p>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Refus√© par Xano</strong><br>
Le Query Builder n'accepte PAS <code>format_timestamp()</code> dans un WHERE.<br>
Message d'erreur : <code>Invalid filter</code>
</div>

<p><strong>Pourquoi √ßa ne marche pas :</strong></p>

<ul>
    <li><code>format_timestamp()</code> est uniquement disponible dans les <strong>Responses</strong></li>
    <li>Le Query Builder SQL de Xano n'expose pas cette fonction dans les conditions WHERE</li>
    <li>Incoh√©rence totale : la fonction existe, mais pas l√† o√π on en a besoin</li>
</ul>

<hr>

<h3>2Ô∏è‚É£ Utiliser les pipes (<code>value|format_timestamp</code>)</h3>

<p><strong>Id√©e :</strong></p>

<pre><code>db.session.start_date|format_timestamp:"Y-m-d" == input.date_debut|format_timestamp:"Y-m-d"
</code></pre>

<p><strong>R√©sultat :</strong></p>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Refus√© aussi</strong><br>
Les pipes ne fonctionnent que dans les <strong>Responses</strong>, jamais dans un WHERE.<br>
Le Query Builder bloque la syntaxe.
</div>

<hr>

<h3>3Ô∏è‚É£ Utiliser <code>to_timestamp()</code> ou <code>parse_timestamp()</code></h3>

<p><strong>Id√©e :</strong></p>

<pre><code>to_timestamp(input.date_debut) == db.session.start_date
</code></pre>

<p><strong>R√©sultat :</strong></p>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Toujours rejet√© dans un WHERE</strong><br>
Ces fonctions existent dans Xano Functions, mais ne sont <strong>pas utilisables</strong> dans la couche SQL du Query Builder.
</div>

<hr>

<h3>4Ô∏è‚É£ Tronquer le timestamp avec modulo (technique SQL classique)</h3>

<p><strong>Id√©e :</strong></p>

<pre><code>timestamp - (timestamp % 86400000) == input.date_debut - (input.date_debut % 86400000)
</code></pre>

<p><strong>Explication :</strong> 86400000 ms = 1 jour. En retirant le modulo, on tronque la date √† minuit.</p>

<p><strong>R√©sultat :</strong></p>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Erreur : Not numeric</strong><br>
Xano ne consid√®re pas <code>input.date_debut</code> comme un nombre dans ce contexte, m√™me si c'est bien un <code>1763578800000</code> en JSON.
</div>

<p><strong>Pourquoi :</strong></p>

<ul>
    <li>Le typage des inputs est <strong>flou</strong> dans Xano</li>
    <li>Un input peut √™tre vu comme string, number, ou timestamp selon le contexte</li>
    <li>Les op√©rations arithm√©tiques ne sont pas toujours autoris√©es</li>
</ul>

<hr>

<h3>5Ô∏è‚É£ Utiliser la fonction SQL <code>date()</code></h3>

<p><strong>Id√©e :</strong></p>

<pre><code>date(db.session.start_date) == date(input.date_debut)
</code></pre>

<p><strong>R√©sultat :</strong></p>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Comparaison toujours fausse</strong><br>
Xano ne convertit <strong>pas correctement</strong> <code>input.date_debut</code> en datetime SQL.
</div>

<p><strong>Ce qui se passe r√©ellement :</strong></p>

<pre><code>DATE(db.session.start_date) ‚Üí 2025-11-19
DATE(input.date_debut)      ‚Üí DATE(1763578800000) ‚ùå
</code></pre>

<p>Xano garde ton timestamp en millisecondes comme un <code>INT</code>, <strong>pas comme un DATETIME</strong>.</p>

<p>En SQL pur, il faudrait :</p>

<pre><code>DATE(FROM_UNIXTIME(input.date_debut / 1000))
</code></pre>

<p><strong>Mais <code>FROM_UNIXTIME()</code> n'est pas accessible dans le Query Builder.</strong></p>

<hr>

<h3>6Ô∏è‚É£ Comparer des plages temporelles (d√©but du jour ‚Üí fin du jour)</h3>

<p><strong>Id√©e :</strong></p>

<p>La m√©thode SQL universelle pour comparer uniquement le jour :</p>

<pre><code>start_date >= d√©but_du_jour
AND start_date < fin_du_jour
</code></pre>

<p><strong>Probl√®me :</strong></p>

<ul>
    <li>Tu ne peux pas <strong>calculer</strong> <code>d√©but_du_jour</code> et <code>fin_du_jour</code> dans un WHERE</li>
    <li>Il faudrait les calculer en amont (dans une Function), mais c'est lourd</li>
    <li>Xano refuse les fonctions n√©cessaires (format, parse) ailleurs que dans les Responses</li>
</ul>

<hr>

<h3>7Ô∏è‚É£ Utiliser un Custom Query avec SQL brut</h3>

<div class="callout callout-tip">
‚ú® <strong>C'EST LA SEULE SOLUTION QUI FONCTIONNE</strong><br>
Si tu utilises un <strong>Custom Query</strong> dans Xano et √©cris directement le SQL, tu peux utiliser <code>FROM_UNIXTIME()</code> et <code>DATE()</code>.
</div>

<p><strong>SQL qui fonctionne :</strong></p>

<pre><code>SELECT *
FROM session
WHERE DATE(start_date) = DATE(FROM_UNIXTIME(:date_debut / 1000))
</code></pre>

<p><strong>Mais :</strong></p>

<ul>
    <li>Tu perds l'interface visuelle du Query Builder</li>
    <li>Tu dois maintenir du SQL √† la main</li>
    <li>√áa casse la promesse "no-code" de Xano</li>
</ul>

<h2>üõë Pourquoi le Query Builder de Xano est inadapt√© ici</h2>

<p>On ne va pas tourner autour du pot. Voici les raisons objectives pour lesquelles Xano est <strong>inadapt√©</strong> pour cette t√¢che basique :</p>

<h3>1. Le Query Builder n'a pas √©t√© pens√© pour manipuler les dates</h3>

<p>Tu n'as acc√®s √† :</p>

<ul>
    <li>‚ùå Aucune vraie fonction SQL (<code>FROM_UNIXTIME</code>, <code>DATE</code>, <code>CAST</code>)</li>
    <li>‚ùå Aucun contr√¥le sur les conversions de timestamps</li>
    <li>‚ùå Aucun cast explicite de types</li>
</ul>

<p>Xano impose une couche d'abstraction, mais <strong>pas compatible</strong> avec des op√©rations basiques sur les dates.</p>

<h3>2. Les fonctions Xano ne sont pas utilisables l√† o√π on en a besoin</h3>

<ul>
    <li><code>format_timestamp()</code> marche en <strong>Response</strong>, mais pas en <strong>WHERE</strong></li>
    <li><code>parse_timestamp()</code> marche dans <strong>Functions</strong>, mais pas en <strong>WHERE</strong></li>
</ul>

<p>Xano n'a <strong>pas un langage homog√®ne</strong> : le Query Builder et les Functions n'ont pas les m√™mes capacit√©s.</p>

<h3>3. Pas de logs SQL, pas de visibilit√©</h3>

<p>Tu ne vois jamais :</p>

<ul>
    <li>Les conversions internes appliqu√©es</li>
    <li>Le SQL final g√©n√©r√©</li>
    <li>Les types manipul√©s (string, number, datetime ?)</li>
</ul>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Debugging impossible</strong><br>
Le "Run & Debug" ne montre que l'entr√©e et la sortie.<br>
Pas de trace interm√©diaire, pas de SQL visible.
</div>

<h3>4. Le typage est flou et change selon le contexte</h3>

<p>Un input JSON <code>"1763578800000"</code> peut √™tre :</p>

<ul>
    <li>Un <strong>string</strong> en WHERE</li>
    <li>Un <strong>number</strong> en Response</li>
    <li>Un <strong>timestamp</strong> ailleurs</li>
    <li>Un <strong>datetime</strong> si pass√© par un parse</li>
    <li>Un <strong>INT MySQL</strong> s'il n'est pas cast√©</li>
</ul>

<p><strong>C'est incoh√©rent.</strong></p>

<h3>5. Ce que tu veux faire est simple... mais pas dans Xano</h3>

<p>Comparer uniquement le <strong>jour</strong> d'un timestamp est :</p>

<ul>
    <li>‚úÖ Trivial en SQL</li>
    <li>‚úÖ Trivial en PHP/Python</li>
    <li>‚úÖ Trivial en JavaScript</li>
    <li>‚úÖ Trivial en NoCode comme Supabase ou Firebase</li>
    <li>‚ùå <strong>Impossible proprement dans Xano Query Builder</strong></li>
</ul>

<p>Parce qu'ils ont <strong>brid√© toutes les routes logiques</strong>.</p>

<h2>üß∞ Solutions de contournement (si tu restes sur Xano)</h2>

<h3>Option 1 : Custom Query avec SQL brut ‚úÖ (recommand√©)</h3>

<p>Utilise un <strong>Custom Query</strong> dans ton endpoint Xano :</p>

<pre><code>SELECT *
FROM session
WHERE DATE(start_date) = DATE(FROM_UNIXTIME(:date_debut / 1000))
</code></pre>

<p><strong>Avantages :</strong></p>

<ul>
    <li>‚úÖ √áa fonctionne</li>
    <li>‚úÖ SQL standard, compr√©hensible</li>
    <li>‚úÖ Performances correctes</li>
</ul>

<p><strong>Inconv√©nients :</strong></p>

<ul>
    <li>‚ùå Tu perds l'interface visuelle</li>
    <li>‚ùå Maintenance manuelle du SQL</li>
</ul>

<hr>

<h3>Option 2 : Calculer la plage en amont (Function) ‚ö†Ô∏è</h3>

<p>Cr√©e une <strong>Function</strong> qui calcule :</p>

<pre><code>{
  "day_start": timestamp du d√©but du jour (00:00:00),
  "day_end": timestamp de fin du jour (23:59:59)
}
</code></pre>

<p>Puis dans ton Query Builder :</p>

<pre><code>start_date >= var.day_start
AND start_date < var.day_end
</code></pre>

<p><strong>Avantages :</strong></p>

<ul>
    <li>‚úÖ Reste dans le Query Builder</li>
    <li>‚úÖ Logique r√©utilisable</li>
</ul>

<p><strong>Inconv√©nients :</strong></p>

<ul>
    <li>‚ùå Code lourd pour une op√©ration simple</li>
    <li>‚ùå N√©cessite une √©tape interm√©diaire</li>
</ul>

<hr>

<h3>Option 3 : Filtrer c√¥t√© WeWeb (JS) ‚ùå (√† √©viter)</h3>

<p>R√©cup√®re TOUTES les sessions, puis filtre en JavaScript dans WeWeb.</p>

<p><strong>Avantages :</strong></p>

<ul>
    <li>‚úÖ Tu contr√¥les tout en JS</li>
</ul>

<p><strong>Inconv√©nients :</strong></p>

<ul>
    <li>‚ùå Performances catastrophiques si tu as beaucoup de sessions</li>
    <li>‚ùå Tu charges des donn√©es inutiles</li>
    <li>‚ùå Pagination impossible</li>
    <li>‚ùå <strong>Mauvaise pratique absolue</strong></li>
</ul>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Ne fais √ßa que si tu as moins de 100 sessions max</strong>
</div>

<h2>üß≠ Exemple concret : Custom Query fonctionnel</h2>

<p>Voici un endpoint Xano complet avec Custom Query :</p>

<h3>√âtape 1Ô∏è‚É£ : Input</h3>

<pre><code>{
  "date_debut": 1763578800000
}
</code></pre>

<h3>√âtape 2Ô∏è‚É£ : Custom Query</h3>

<pre><code>SELECT
  session.id,
  session.title,
  session.start_date,
  session.end_date
FROM session
WHERE DATE(start_date) = DATE(FROM_UNIXTIME(:date_debut / 1000))
ORDER BY start_date ASC
</code></pre>

<h3>√âtape 3Ô∏è‚É£ : Response</h3>

<pre><code>[
  {
    "id": 42,
    "title": "Session de r√©paration",
    "start_date": "2025-11-19 14:30:00",
    "end_date": "2025-11-19 16:30:00"
  },
  {
    "id": 43,
    "title": "Session de diagnostic",
    "start_date": "2025-11-19 09:00:00",
    "end_date": "2025-11-19 11:00:00"
  }
]
</code></pre>

<p><strong>R√©sultat :</strong> Toutes les sessions du 19 novembre 2025, peu importe l'heure. ‚úÖ</p>

<h2>üìå √Ä retenir</h2>

<div class="summary">
üìå <strong>√Ä retenir :</strong>
<ul>
  <li>Le <strong>Query Builder de Xano</strong> ne permet pas de manipuler les dates dans les WHERE (pas de <code>format_timestamp</code>, <code>parse_timestamp</code>, <code>FROM_UNIXTIME</code>)</li>
  <li>Les fonctions Xano existent, mais <strong>ne sont pas utilisables partout</strong> (incoh√©rence entre Responses, Functions, et Query Builder)</li>
  <li>Le typage des inputs est <strong>flou</strong> : un timestamp peut √™tre vu comme string, number, ou datetime selon le contexte</li>
  <li>Pas de <strong>logs SQL</strong>, pas de visibilit√© sur les conversions internes ‚Üí debugging impossible</li>
  <li><strong>Solution recommand√©e :</strong> Utiliser un <strong>Custom Query</strong> avec SQL brut et <code>FROM_UNIXTIME()</code></li>
  <li><strong>Alternative :</strong> Calculer la plage temporelle en amont dans une Function, puis utiliser des comparaisons <code>&gt;=</code> et <code>&lt;</code></li>
  <li>‚ùå <strong>√âviter absolument :</strong> Filtrer c√¥t√© WeWeb (performances catastrophiques)</li>
</ul>
</div>

<h2>üß† Quiz rapide</h2>

<p><strong>Question :</strong> Pourquoi <code>format_timestamp(db.session.start_date, "Y-m-d")</code> ne fonctionne pas dans un WHERE ?</p>

<p><strong>R√©ponse attendue :</strong></p>

<ul>
    <li><code>format_timestamp()</code> est uniquement disponible dans les <strong>Responses</strong></li>
    <li>Le Query Builder SQL de Xano n'expose pas cette fonction dans les conditions WHERE</li>
    <li>Il faut utiliser un <strong>Custom Query</strong> avec <code>DATE()</code> et <code>FROM_UNIXTIME()</code> pour contourner cette limitation</li>
</ul>

<h2>üîó Liens utiles</h2>

<ul>
    <li><a href="https://docs.xano.com/working-with-data/custom-query" target="_blank">Documentation Xano : Custom Query</a></li>
    <li><a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html" target="_blank">Documentation MySQL : Fonctions de date et heure</a></li>
    <li><a href="https://docs.xano.com/working-with-data/functions" target="_blank">Documentation Xano : Functions</a></li>
</ul>

<div class="callout callout-advanced">
üî¨ <strong>Pour aller plus loin</strong><br>
Si tu veux approfondir les limitations du Query Builder et les strat√©gies de contournement, explore :
<ul>
  <li>Les <strong>Custom Queries</strong> pour un contr√¥le SQL total</li>
  <li>Les <strong>Database Triggers</strong> pour automatiser les calculs de dates</li>
  <li>Les <strong>Computed Fields</strong> pour stocker des dates tronqu√©es au jour (si utilis√© fr√©quemment)</li>
</ul>
</div>
