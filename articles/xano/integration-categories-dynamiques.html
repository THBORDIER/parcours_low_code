<h1>IntÃ©gration Xano + WeWeb : Afficher dynamiquement les catÃ©gories pour chaque rÃ©parateur</h1>

<p class="subtitle">Dans cet article, je vous explique comment j'ai rÃ©ussi Ã  crÃ©er une API Xano unique qui renvoie les rÃ©parateurs avec leurs catÃ©gories associÃ©es, et comment les afficher proprement dans WeWeb grÃ¢ce aux jointures et au binding dynamique.</p>

<!-- Metadata block -->
<div class="metadata">
    <p>ğŸ·ï¸ <strong>CatÃ©gorie:</strong> Xano</p>
    <p>ğŸ¯ <strong>Niveau:</strong> IntermÃ©diaire</p>
    <p>ğŸ” <strong>Mots-clÃ©s:</strong> Xano, WeWeb, API, Jointures, Query All Records, Binding dynamique</p>
    <p>ğŸ“… <strong>Mise Ã  jour:</strong> 18/10/2025</p>
    <p>â±ï¸ <strong>Temps passÃ©:</strong> 2h</p>
    <p>âš™ï¸ <strong>Stack:</strong> Xano + WeWeb</p>
</div>

<!-- TL;DR -->
<div class="tldr">
âœ… <strong>TL;DR :</strong>
GrÃ¢ce aux <strong>jointures dans Xano</strong> (Query All Records + Add-on), j'ai crÃ©Ã© une API unique qui renvoie les rÃ©parateurs avec leurs catÃ©gories. RÃ©sultat : une seule requÃªte API pour alimenter WeWeb, un JSON structurÃ© facile Ã  binder, et des performances optimisÃ©es.
</div>

<h2>ğŸ¤” ProblÃ¨me rencontrÃ©</h2>

<p><strong>ğŸ›‘ Contexte :</strong> Je dÃ©veloppe une application de rÃ©servation de services de rÃ©paration. Mon objectif est d'afficher une liste de rÃ©parateurs sous forme de cartes dans WeWeb, avec pour chaque rÃ©parateur :</p>

<ul>
    <li>Son nom (ex: Joshua)</li>
    <li>Sa catÃ©gorie principale (ex: VÃ©lo)</li>
    <li>L'icÃ´ne associÃ©e Ã  sa catÃ©gorie (ex: ğŸš´)</li>
    <li>Le prix de ses services</li>
</ul>

<p><strong>ğŸ’¡ Exemple utilisateur :</strong> Quand un utilisateur arrive sur la page, il voit immÃ©diatement dans chaque carte : "Joshua - VÃ©lo ğŸš´ - 16,46 â‚¬"</p>

<p><strong>âš ï¸ Le problÃ¨me :</strong> Mon endpoint Xano <code>/repairer/{id}</code> ne retournait que les donnÃ©es de la table <code>repairer</code>, sans les informations de catÃ©gories. Je ne savais pas comment rÃ©cupÃ©rer les relations entre rÃ©parateurs et catÃ©gories dans une seule rÃ©ponse API.</p>

<h2>ğŸ” Explication simplifiÃ©e</h2>

<p>Dans une base de donnÃ©es relationnelle comme Xano, les informations sont souvent rÃ©parties dans plusieurs tables :</p>

<ul>
    <li><strong>Table <code>repairer</code> :</strong> id, firstname, description...</li>
    <li><strong>Table <code>repairer_category</code> :</strong> table de liaison (many-to-many) entre rÃ©parateurs et catÃ©gories</li>
    <li><strong>Table <code>category</code> :</strong> name, icon, price...</li>
</ul>

<p>ğŸ§  <strong>Analogie :</strong> Imaginez une bibliothÃ¨que. Vous avez :</p>
<ul>
    <li>Une Ã©tagÃ¨re "Auteurs" (table <code>repairer</code>)</li>
    <li>Une Ã©tagÃ¨re "Genres littÃ©raires" (table <code>category</code>)</li>
    <li>Un registre qui dit "quel auteur Ã©crit dans quel genre" (table <code>repairer_category</code>)</li>
</ul>

<p>Pour savoir qu'un auteur Ã©crit du "Policier", il faut consulter les trois Ã©tagÃ¨res. En SQL classique, on utilise des <strong>JOIN</strong>. Dans Xano, on utilise <strong>Query All Records + Add-on</strong>.</p>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
PlutÃ´t que de crÃ©er plusieurs endpoints (un pour les rÃ©parateurs, un pour les catÃ©gories), on peut tout regrouper dans une seule rÃ©ponse JSON grÃ¢ce aux jointures Xano. C'est plus rapide, plus simple Ã  maintenir, et WeWeb adore Ã§a !
</div>

<h2>ğŸ§ª Solution : ProcÃ©dure Ã©tape par Ã©tape</h2>

<h3>Ã‰tape 1ï¸âƒ£ : Utiliser Query All Records dans Xano</h3>

<p>Dans mon endpoint Xano, j'ai remplacÃ© le simple <code>Get Record</code> par un <strong>Query All Records</strong> sur la table <code>repairer</code>.</p>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
<code>Query All Records</code> retourne une <strong>liste</strong>, mÃªme s'il n'y a qu'un seul rÃ©sultat. Pensez Ã  filtrer avec <code>WHERE id = {repairer_id}</code> si vous voulez un rÃ©parateur spÃ©cifique.
</div>

<h3>Ã‰tape 2ï¸âƒ£ : Ajouter un Add-on pour joindre la table de liaison</h3>

<p>Dans le Query All Records, j'ai cliquÃ© sur <strong>Add-on</strong> et sÃ©lectionnÃ© :</p>

<ul>
    <li><strong>Table :</strong> <code>repairer_category</code></li>
    <li><strong>Type de relation :</strong> One-to-many (un rÃ©parateur peut avoir plusieurs catÃ©gories)</li>
    <li><strong>Champ de liaison :</strong> <code>repairer_category.repairer_id = repairer.id</code></li>
</ul>

<h3>Ã‰tape 3ï¸âƒ£ : Ajouter une seconde jointure vers la table category</h3>

<p>Ensuite, j'ai ajoutÃ© un second Add-on depuis <code>repairer_category</code> vers <code>category</code> :</p>

<ul>
    <li><strong>Table :</strong> <code>category</code></li>
    <li><strong>Champ de liaison :</strong> <code>repairer_category.category_id = category.id</code></li>
</ul>

<h3>Ã‰tape 4ï¸âƒ£ : SÃ©lectionner les champs pertinents</h3>

<p>Dans le Add-on, j'ai sÃ©lectionnÃ© uniquement les champs dont j'ai besoin :</p>

<ul>
    <li><code>category.name</code></li>
    <li><code>category.icon</code></li>
    <li><code>category.price</code> (si le prix est stockÃ© par catÃ©gorie)</li>
</ul>

<h3>Ã‰tape 5ï¸âƒ£ : Tester la rÃ©ponse API</h3>

<p>RÃ©sultat de mon endpoint <code>GET /repairer</code> :</p>

<pre><code>[
  {
    "id": 2,
    "firstname": "Joshua",
    "description": "Expert en rÃ©paration de vÃ©los",
    "categories": [
      {
        "name": "VÃ©lo",
        "icon": "ğŸš´",
        "price": 16.46
      }
    ]
  }
]
</code></pre>

<div class="callout callout-tip">
âœ¨ <strong>Astuce : Aplatir la structure</strong><br>
Si vous voulez Ã©viter <code>categories[0].name</code> dans WeWeb, ajoutez un champ calculÃ© dans Xano avec <strong>Add Field</strong> :
<ul>
    <li><code>category_name = _category[0].name</code></li>
    <li><code>category_icon = _category[0].icon</code></li>
</ul>
Ainsi, dans WeWeb, vous pourrez simplement utiliser <code>current.category_name</code> au lieu de <code>current.categories[0].name</code>.
</div>

<h2>ğŸ§­ IntÃ©gration dans WeWeb</h2>

<h3>ğŸ¯ Objectif</h3>

<p>Afficher dynamiquement dans chaque carte WeWeb :</p>
<ul>
    <li>Le nom du rÃ©parateur</li>
    <li>Le label de catÃ©gorie (ex: VÃ©lo)</li>
    <li>L'icÃ´ne catÃ©gorie (ex: ğŸš´)</li>
</ul>

<h3>ğŸ›  Configuration WeWeb</h3>

<p><strong>1. CrÃ©er une Collection de donnÃ©es :</strong></p>
<ul>
    <li>Allez dans <strong>Data Sources</strong></li>
    <li>Ajoutez une REST API avec votre endpoint Xano</li>
    <li>Nommez-la par exemple <code>repairers_list</code></li>
</ul>

<p><strong>2. CrÃ©er un Repeater (boucle) :</strong></p>
<ul>
    <li>Ajoutez un composant <strong>List</strong> ou <strong>Repeater</strong></li>
    <li>Bindez la source de donnÃ©es Ã  <code>repairers_list.data</code></li>
</ul>

<p><strong>3. Binder les donnÃ©es dans chaque carte :</strong></p>

<p>Pour afficher le nom du rÃ©parateur :</p>
<pre><code>current.firstname</code></pre>

<p>Pour afficher le nom de catÃ©gorie :</p>
<pre><code>current.categories[0].name</code></pre>

<p>Pour afficher l'icÃ´ne catÃ©gorie :</p>
<pre><code>current.categories[0].icon</code></pre>

<div class="callout callout-advanced">
ğŸ”¬ <strong>Pour aller plus loin</strong><br>
<strong>GÃ©rer plusieurs catÃ©gories par rÃ©parateur :</strong><br>
Si un rÃ©parateur peut avoir plusieurs catÃ©gories, utilisez un second repeater Ã  l'intÃ©rieur de chaque carte, bindÃ© sur <code>current.categories</code>, pour afficher tous les badges de catÃ©gories.
</div>

<h2>ğŸ“Œ RÃ©sumÃ© final</h2>

<div class="summary">
ğŸ“Œ <strong>Ã€ retenir :</strong>
<ul>
  <li><strong>Query All Records + Add-on</strong> dans Xano permet de joindre plusieurs tables et d'obtenir un JSON structurÃ© en une seule requÃªte</li>
  <li>Ã‰vitez de crÃ©er plusieurs endpoints sÃ©parÃ©s : regroupez tout dans une API unique pour optimiser les performances</li>
  <li>Utilisez <strong>Add Field</strong> dans Xano pour aplatir la structure JSON si vous voulez simplifier le binding dans WeWeb</li>
  <li>Dans WeWeb, le contexte <code>current</code> d'un repeater contient automatiquement l'item en cours, accessible via <code>current.field_name</code></li>
  <li>Cette mÃ©thode est facilement extensible : vous pouvez ajouter d'autres relations (sessions, rÃ©servations, avis...) avec la mÃªme logique</li>
</ul>
</div>

<h2>ğŸ§  Quiz rapide (pour tester votre comprÃ©hension)</h2>

<p><strong>Question :</strong> Pourquoi utiliser <code>Query All Records</code> plutÃ´t que <code>Get Record</code> dans Xano ?</p>

<p><strong>âœ… RÃ©ponse attendue :</strong> <code>Query All Records</code> permet d'utiliser des <strong>Add-on</strong> pour effectuer des jointures avec d'autres tables, ce qui n'est pas possible avec <code>Get Record</code>. Cela permet d'obtenir des donnÃ©es relationnelles dans une seule rÃ©ponse API.</p>

<h2>ğŸ”— Liens utiles</h2>

<ul>
    <li><a href="https://docs.xano.com/working-with-your-database/queries" target="_blank">Documentation Xano : Working with Queries</a></li>
    <li><a href="https://docs.xano.com/working-with-your-database/add-ons" target="_blank">Documentation Xano : Add-ons</a></li>
    <li><a href="https://docs.weweb.io/data-sources.html" target="_blank">Documentation WeWeb : Data Sources</a></li>
    <li><a href="#" data-article="../articles/xano/api-endpoints.html">Article connexe : CrÃ©er des API endpoints dans Xano</a></li>
</ul>

<h2>âœ¨ Tableau rÃ©capitulatif des avantages</h2>

<table>
    <thead>
        <tr>
            <th>Avantage</th>
            <th>Impact</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Une seule API</td>
            <td>Moins d'appels rÃ©seau, temps de chargement rÃ©duit</td>
        </tr>
        <tr>
            <td>JSON structurÃ©</td>
            <td>Facile Ã  binder dans WeWeb</td>
        </tr>
        <tr>
            <td>FlexibilitÃ©</td>
            <td>Ajout facile d'autres relations (sessions, rÃ©servationsâ€¦)</td>
        </tr>
        <tr>
            <td>MaintenabilitÃ©</td>
            <td>Un seul endpoint Ã  documenter et maintenir</td>
        </tr>
    </tbody>
</table>
