<h1>GÃ©nÃ©ration d'un numÃ©ro de devis incrÃ©mental avec WeWeb et Xano</h1>

<p class="subtitle">Retour d'expÃ©rience dÃ©taillÃ© sur la gÃ©nÃ©ration automatique de numÃ©ros de devis : format lisible, incrÃ©mentation annuelle, et maÃ®trise du typage Xano.</p>

<!-- Metadata block -->
<div class="metadata">
    <p>ğŸ·ï¸ <strong>CatÃ©gorie:</strong> Xano</p>
    <p>ğŸ¯ <strong>Niveau:</strong> IntermÃ©diaire</p>
    <p>ğŸ” <strong>Mots-clÃ©s:</strong> NumÃ©ro incrÃ©mental, Direct Database Query, COALESCE, INTEGER filter, Scalar value, Response type single, Timestamp PostgreSQL, to_timestamp, date_trunc</p>
    <p>ğŸ“… <strong>Mise Ã  jour:</strong> 18/01/2026</p>
    <p>â±ï¸ <strong>Temps passÃ©:</strong> 30 min</p>
    <p>âš™ï¸ <strong>Stack:</strong> WeWeb + Xano</p>
</div>

<!-- TL;DR -->
<div class="tldr">
âœ… <strong>TL;DR :</strong>
La gÃ©nÃ©ration d'un numÃ©ro de devis incrÃ©mental (format DV-2026-001) avec Xano nÃ©cessite de bien comprendre la diffÃ©rence entre <strong>valeurs scalaires</strong>, <strong>objets</strong> et <strong>listes</strong>. L'erreur la plus frÃ©quente : passer un step entier (<code>x1</code>) au lieu d'une propriÃ©tÃ© prÃ©cise (<code>x1[0].next_num</code>) dans un champ typÃ© INTEGER ou TEXT.
</div>

<h2>ğŸ¤” ProblÃ¨me rencontrÃ©</h2>

<p>Dans le cadre du Projet 10 de ma formation, j'ai dÃ©veloppÃ© une fonctionnalitÃ© complÃ¨te de crÃ©ation de devis avec WeWeb (front-end no-code) et Xano (back-end).</p>

<p><strong>L'un des points les plus sensibles</strong> du projet a Ã©tÃ© la gÃ©nÃ©ration automatique d'un numÃ©ro de devis, avec les contraintes suivantes :</p>

<ul>
    <li><strong>Format lisible</strong> : <code>DV-ANNEE-XXX</code> (exemple : DV-2026-001)</li>
    <li><strong>IncrÃ©mentation automatique</strong> : XXX augmente de 1 Ã  chaque devis</li>
    <li><strong>Remise Ã  zÃ©ro chaque annÃ©e</strong></li>
    <li><strong>CompatibilitÃ© avec Xano</strong> : PostgreSQL, champs typÃ©s strictement</li>
    <li><strong>IntÃ©gration fluide avec WeWeb</strong></li>
</ul>

<p>ğŸ’¡ <strong>Exemple utilisateur :</strong> Un utilisateur crÃ©e un devis le 15 janvier 2026. Le systÃ¨me doit automatiquement gÃ©nÃ©rer le numÃ©ro <code>DV-2026-001</code>. Le lendemain, un nouveau devis doit obtenir <code>DV-2026-002</code>, et ainsi de suite.</p>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
Ce qui semblait simple au dÃ©part s'est rÃ©vÃ©lÃ© Ãªtre un excellent cas d'Ã©cole sur les diffÃ©rences entre <strong>donnÃ©es scalaires</strong>, <strong>objets</strong>, <strong>listes</strong>, et sur la gestion correcte des requÃªtes SQL dans Xano.
</div>

<h2>ğŸ—ï¸ Architecture choisie</h2>

<h3>SÃ©paration des responsabilitÃ©s</h3>

<p><strong>Xano</strong> est la source de vÃ©ritÃ© :</p>
<ul>
    <li>Calcul du prochain numÃ©ro</li>
    <li>Insertion du devis</li>
</ul>

<p><strong>WeWeb</strong> se contente :</p>
<ul>
    <li>D'appeler l'endpoint</li>
    <li>D'afficher le rÃ©sultat formatÃ©</li>
</ul>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
Cette sÃ©paration est essentielle pour Ã©viter les <strong>doublons</strong>, les <strong>conflits multi-utilisateurs</strong> et les <strong>incohÃ©rences mÃ©tier</strong>. Ne jamais gÃ©nÃ©rer des identifiants mÃ©tier cÃ´tÃ© front-end.
</div>

<h3>Choix des champs cÃ´tÃ© base de donnÃ©es</h3>

<p>Dans la table <code>P10_devis</code>, les champs clÃ©s sont :</p>

<ul>
    <li><code>numero_devis</code> â†’ <strong>INTEGER</strong><br>
        Contient uniquement la partie incrÃ©mentale (1, 2, 3, etc.)</li>
    <li><code>reference</code> â†’ <strong>TEXT</strong><br>
        Contient le format lisible (DV-2026-001)</li>
    <li><code>created_at</code> â†’ <strong>BIGINT</strong><br>
        Timestamp en millisecondes (format Xano)</li>
</ul>

<p><strong>Ce choix est volontaire :</strong></p>
<ul>
    <li>Le champ <strong>numÃ©rique</strong> sert aux <strong>calculs</strong></li>
    <li>Le champ <strong>texte</strong> sert Ã  l'<strong>affichage</strong> et Ã  la <strong>lisibilitÃ© mÃ©tier</strong></li>
</ul>

<h2>ğŸ” Premier Ã©cueil : filtrer par annÃ©e avec created_at</h2>

<h3>Erreur initiale</h3>

<p>Tentative de comparaison directe entre <code>created_at</code> et <code>now()</code> â†’ PostgreSQL rejetait la requÃªte.</p>

<h3>Cause rÃ©elle</h3>

<ul>
    <li><code>created_at</code> est un <strong>BIGINT</strong> (millisecondes)</li>
    <li><code>now()</code> retourne un <strong>timestamp PostgreSQL</strong></li>
    <li>Comparaison invalide sans conversion</li>
</ul>

<h3>RÃ©solution</h3>

<p>Conversion explicite du timestamp millisecondes vers un timestamp PostgreSQL :</p>

<pre><code>to_timestamp(created_at / 1000.0)</code></pre>

<p>Filtrage annuel correct :</p>

<pre><code>WHERE to_timestamp(created_at / 1000.0) >= date_trunc('year', now())
  AND to_timestamp(created_at / 1000.0) <  date_trunc('year', now()) + INTERVAL '1 year'</code></pre>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
<code>date_trunc('year', now())</code> renvoie le <strong>1er janvier de l'annÃ©e en cours Ã  00:00:00</strong>, ce qui permet de filtrer uniquement les enregistrements de l'annÃ©e courante.
</div>

<h2>ğŸ§ª RequÃªte SQL correcte pour obtenir le prochain numÃ©ro</h2>

<h3>Objectif</h3>

<ul>
    <li>RÃ©cupÃ©rer le dernier numÃ©ro de devis de l'annÃ©e</li>
    <li>Y ajouter +1</li>
    <li><strong>Sans insÃ©rer quoi que ce soit</strong> Ã  ce stade</li>
</ul>

<h3>RequÃªte SQL finale</h3>

<pre><code>SELECT
  COALESCE(MAX(numero_devis), 0) + 1 AS next_num
FROM x1_15
WHERE to_timestamp(created_at / 1000.0) >= date_trunc('year', now())
  AND to_timestamp(created_at / 1000.0) <  date_trunc('year', now()) + INTERVAL '1 year';</code></pre>

<p><strong>Cette requÃªte :</strong></p>
<ul>
    <li>Fonctionne mÃªme s'il n'existe <strong>aucun devis</strong> (grÃ¢ce Ã  <code>COALESCE</code>)</li>
    <li>Renvoie toujours un <strong>entier valide</strong></li>
    <li>Filtre uniquement les devis de l'<strong>annÃ©e courante</strong></li>
</ul>

<div class="callout callout-advanced">
ğŸ”¬ <strong>Pour aller plus loin</strong><br>
<code>COALESCE(MAX(numero_devis), 0)</code> renvoie 0 si aucun devis n'existe. Cela garantit que le premier numÃ©ro de l'annÃ©e sera toujours <strong>1</strong> (0 + 1).
</div>

<h2>ğŸ›‘ DeuxiÃ¨me Ã©cueil majeur : objets vs valeurs scalaires dans Xano</h2>

<h3>SymptÃ´me</h3>

<p>Erreur rÃ©currente :</p>

<pre><code>Integer filter requires a scalar value
Text filter requires an integer, float, string or boolean value</code></pre>

<h3>Cause rÃ©elle</h3>

<p>Dans Xano :</p>
<ul>
    <li>Une <strong>Direct Database Query</strong> retourne <strong>toujours une LISTE</strong></li>
    <li>MÃªme si la requÃªte SQL renvoie <strong>une seule ligne</strong></li>
</ul>

<p><strong>Exemple rÃ©el :</strong></p>

<pre><code>[
  {
    "next_num": 12
  }
]</code></pre>

<h3>Erreur classique</h3>

<p>Passer <code>x1</code> ou <code>x1[0]</code> dans un champ <code>integer</code> ou <code>text</code>.</p>

<p>Xano attend :</p>
<ul>
    <li>Un <strong>scalaire</strong> (nombre, texte, boolÃ©en)</li>
    <li>Pas un <strong>objet</strong></li>
    <li>Pas une <strong>liste</strong></li>
</ul>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
<strong>RÃ¨gle fondamentale :</strong> Dans Xano, on n'injecte <strong>jamais un step entier</strong> dans un champ typÃ©. On injecte <strong>toujours une propriÃ©tÃ© prÃ©cise</strong>.
</div>

<h3>Exemple correct</h3>

<p>Pour <code>numero_devis</code> (INTEGER) :</p>
<pre><code>x2[0].next_num</code></pre>

<p>Pour <code>reference</code> (TEXT) :</p>
<pre><code>x1[0].next_devis_label</code></pre>

<h2>âš¡ Optimisation : une seule requÃªte SQL</h2>

<p>Pour Ã©viter <strong>deux requÃªtes sÃ©parÃ©es</strong>, une seule requÃªte peut renvoyer :</p>
<ul>
    <li>Le prochain numÃ©ro (<code>next_num</code>)</li>
    <li>Le texte formatÃ© (<code>next_devis_label</code>)</li>
</ul>

<pre><code>SELECT
  COALESCE(MAX(numero_devis), 0) + 1 AS next_num,
  'DV-' ||
  EXTRACT(YEAR FROM now())::int ||
  '-' ||
  LPAD((COALESCE(MAX(numero_devis), 0) + 1)::text, 3, '0')
  AS next_devis_label
FROM x1_15
WHERE to_timestamp(created_at / 1000.0) >= date_trunc('year', now())
  AND to_timestamp(created_at / 1000.0) <  date_trunc('year', now()) + INTERVAL '1 year';</code></pre>

<h3>Mapping Xano</h3>

<ul>
    <li><code>numero_devis</code> â†’ <code>x1[0].next_num</code></li>
    <li><code>reference</code> â†’ <code>x1[0].next_devis_label</code></li>
</ul>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
<code>LPAD(..., 3, '0')</code> garantit un formatage sur <strong>3 chiffres</strong> : 001, 002, ..., 999.
</div>

<h2>ğŸ”§ Importance du Response type = single</h2>

<p>Un point critique souvent ignorÃ© :</p>

<p>Si le <strong>Response type</strong> n'est pas cohÃ©rent avec le rÃ©sultat SQL, Xano peut <strong>encapsuler ou mal interprÃ©ter</strong> la rÃ©ponse.</p>

<p><strong>Le passage du Response type Ã  <code>single</code> a permis :</strong></p>
<ul>
    <li>Une lecture plus claire</li>
    <li>Un mapping plus fiable</li>
    <li>La disparition de certains effets de bord</li>
</ul>

<div class="callout callout-advanced">
ğŸ”¬ <strong>Pour aller plus loin</strong><br>
Si votre requÃªte SQL renvoie une seule ligne, configurez le <strong>Response type</strong> Ã  <code>single</code>. Si elle renvoie plusieurs lignes, utilisez <code>list</code>.
</div>

<h2>ğŸ§° Exemple concret : workflow complet</h2>

<h3>Ã‰tape 1ï¸âƒ£ : Endpoint Xano <code>POST /devis/create</code></h3>

<ol>
    <li><strong>Direct Database Query</strong> : rÃ©cupÃ©rer <code>next_num</code> et <code>next_devis_label</code></li>
    <li><strong>Add Database Record</strong> :
        <ul>
            <li><code>numero_devis</code> â†’ <code>x1[0].next_num</code></li>
            <li><code>reference</code> â†’ <code>x1[0].next_devis_label</code></li>
            <li>Autres champs mÃ©tier (client, montant, etc.)</li>
        </ul>
    </li>
    <li><strong>Return</strong> : le devis crÃ©Ã©</li>
</ol>

<h3>Ã‰tape 2ï¸âƒ£ : WeWeb</h3>

<ol>
    <li>L'utilisateur clique sur "CrÃ©er un devis"</li>
    <li>WeWeb appelle l'endpoint <code>POST /devis/create</code> avec les donnÃ©es du formulaire</li>
    <li>Xano gÃ©nÃ¨re le numÃ©ro et insÃ¨re le devis</li>
    <li>WeWeb affiche le numÃ©ro gÃ©nÃ©rÃ© : <code>DV-2026-042</code></li>
</ol>

<!-- Final summary -->
<div class="summary">
ğŸ“Œ <strong>Ã€ retenir :</strong>
<ul>
  <li><strong>SÃ©parer les responsabilitÃ©s</strong> : Xano gÃ©nÃ¨re les identifiants, WeWeb affiche</li>
  <li><strong>Comprendre le typage Xano</strong> : Direct Database Query renvoie toujours une liste</li>
  <li><strong>Injecter des scalaires</strong> : <code>x1[0].propriÃ©tÃ©</code>, jamais <code>x1</code> ou <code>x1[0]</code></li>
  <li><strong>Utiliser COALESCE</strong> : pour gÃ©rer le cas "aucun devis existant"</li>
  <li><strong>Convertir les timestamps</strong> : <code>to_timestamp(created_at / 1000.0)</code></li>
  <li><strong>Configurer Response type</strong> : <code>single</code> si une seule ligne, <code>list</code> sinon</li>
</ul>
</div>

<h2>ğŸ“ Quick Quiz</h2>

<p>ğŸ§  <strong>Question :</strong> Quelle est l'erreur dans ce mapping Xano ?</p>

<pre><code>numero_devis (INTEGER) â†’ x1[0]</code></pre>

<details>
<summary>âœ… <strong>Voir la rÃ©ponse</strong></summary>
<p><strong>RÃ©ponse :</strong> On injecte un <strong>objet</strong> (<code>x1[0]</code>) au lieu d'un <strong>scalaire</strong>. La correction : <code>x1[0].next_num</code></p>
</details>

<h2>ğŸ”— Liens utiles</h2>

<ul>
    <li><a href="https://docs.xano.com/working-with-your-database/database-requests" target="_blank">Xano Documentation : Database Requests</a></li>
    <li><a href="https://www.postgresql.org/docs/current/functions-datetime.html" target="_blank">PostgreSQL : Date/Time Functions</a></li>
    <li><a href="https://docs.xano.com/building-apis/the-function-stack" target="_blank">Xano Function Stack : Response Types</a></li>
</ul>

<h2>ğŸ’¡ Bilan personnel</h2>

<p>Ce problÃ¨me, bien que frustrant au dÃ©part, a Ã©tÃ© <strong>extrÃªmement formateur</strong>.</p>

<p><strong>Il m'a permis de :</strong></p>
<ul>
    <li>MaÃ®triser les <strong>requÃªtes SQL custom</strong> dans Xano</li>
    <li>Comprendre les <strong>contraintes de typage strict</strong></li>
    <li>Construire une logique <strong>robuste et maintenable</strong></li>
    <li>Ã‰viter des <strong>erreurs critiques en production</strong></li>
</ul>

<p>C'est exactement le type de difficultÃ© qui transforme un projet no-code en <strong>vÃ©ritable expÃ©rience d'ingÃ©nierie logicielle</strong>.</p>
