<h1>Comprendre la rÃ©alitÃ© des middlewares dans Xano</h1>

<p class="subtitle">ProblÃ©matique, limites techniques et implÃ©mentation d'une sÃ©curitÃ© par rÃ´le</p>

<div class="metadata">
    <p>ğŸ·ï¸ <strong>CatÃ©gorie:</strong> Xano</p>
    <p>ğŸ¯ <strong>Niveau:</strong> AvancÃ©</p>
    <p>ğŸ” <strong>Mots-clÃ©s:</strong> Middleware, SÃ©curitÃ© verticale, check_role, HTTP 403, Precondition, Return Response, Function Stack, Playground, $auth.id, Limitation Xano</p>
    <p>ğŸ“… <strong>Mise Ã  jour:</strong> 10/12/2025</p>
    <p>â±ï¸ <strong>Temps passÃ©:</strong> 3h</p>
    <p>âš™ï¸ <strong>Stack:</strong> WeWeb + Xano</p>
</div>

<div class="tldr">
âœ… <strong>TL;DR :</strong>
Les middlewares Xano ne peuvent <strong>PAS</strong> bloquer l'exÃ©cution d'un endpoint, mÃªme en cas d'erreur. Pour une sÃ©curitÃ© par rÃ´le, il faut utiliser une fonction <code>check_role()</code> appelÃ©e en dÃ©but de chaque endpoint critique, avec un <code>Return Response 403</code> direct.
</div>

<h2>ğŸ¯ Le besoin initial</h2>

<p>La crÃ©ation d'une <strong>sÃ©curitÃ© verticale</strong> (contrÃ´le par rÃ´le : client, rÃ©parateur, adminâ€¦) est un besoin courant dans les applications multi-utilisateurs.</p>

<p>L'objectif initial Ã©tait simple :</p>

<ul>
    <li>Interroger la table <code>users</code> pour rÃ©cupÃ©rer le rÃ´le de l'utilisateur authentifiÃ©</li>
    <li>VÃ©rifier si ce rÃ´le correspond Ã  celui attendu (ex : "repairer")</li>
    <li>Bloquer immÃ©diatement la requÃªte en cas de mismatch</li>
    <li>Retourner un HTTP 403 "Forbidden"</li>
</ul>

<p>Cette logique est classique, alignÃ©e sur ce que proposent tous les frameworks backend (Express, Laravel, Djangoâ€¦).</p>

<h2>ğŸ§ª PremiÃ¨re approche : utiliser un middleware Xano</h2>

<p>Xano propose des <strong>middlewares pre/post</strong> censÃ©s se dÃ©clencher avant ou aprÃ¨s l'exÃ©cution d'un endpoint. Sur le papier, cela semble l'outil idÃ©al pour une sÃ©curitÃ© verticale.</p>

<p>Un middleware Xano dispose de :</p>

<ul>
    <li>Une entrÃ©e <code>vars</code></li>
    <li>Une entrÃ©e <code>type</code> (pre/post)</li>
    <li>Un pipeline de fonctions</li>
    <li>La possibilitÃ© d'ajouter des conditions (Precondition)</li>
    <li>La possibilitÃ© de renvoyer des erreurs</li>
</ul>

<p>L'idÃ©e Ã©tait donc de crÃ©er un middleware "check_role" :</p>

<ol>
    <li>RÃ©cupÃ©ration de l'utilisateur via <code>$auth.id</code></li>
    <li>VÃ©rification de son rÃ´le dans la table users</li>
    <li>Si rÃ´le incorrect â†’ renvoi d'une erreur 401/403</li>
    <li>Sinon â†’ laisser passer la requÃªte</li>
</ol>

<h2>ğŸ›‘ Le problÃ¨me dÃ©couvert</h2>

<p>AprÃ¨s de nombreuses tentatives et des tests croisÃ©s avec plusieurs utilisateurs, le constat est devenu clair :</p>

<div class="callout callout-warning">
âš ï¸ <strong>Attention â€” Limitation critique</strong><br>
MÃªme si un middleware Xano renvoie une erreur, il <strong>n'interrompt pas</strong> la requÃªte API. L'endpoint continue de s'exÃ©cuter normalement.
</div>

<p>Voici les comportements observÃ©s :</p>

<ul>
    <li>Une <strong>Precondition Ã©chouÃ©e</strong> stoppe uniquement l'exÃ©cution du middleware, pas celle de l'endpoint</li>
    <li>Un bloc <strong>Return</strong> s'arrÃªte dans le middleware, mais laisse passer l'API derriÃ¨re</li>
    <li>Xano <strong>n'exÃ©cute jamais</strong> de <code>HTTP Return Response</code> depuis un middleware</li>
    <li>Aucune erreur middleware n'empÃªche l'API attachÃ©e de s'exÃ©cuter</li>
</ul>

<p><strong>Le rÃ©sultat observable :</strong></p>

<ul>
    <li>Le middleware signale une erreur dans le debugger</li>
    <li>Mais le endpoint continue normalement</li>
    <li>La ressource est supprimÃ©e malgrÃ© l'Ã©chec du contrÃ´le de rÃ´le</li>
</ul>

<p>Autrement dit :</p>

<pre><code>Un middleware Xano n'a aucune capacitÃ© Ã  sÃ©curiser une API.
C'est une limitation technique structurelle de Xano.</code></pre>

<h2>ğŸ” Les faux positifs du Playground</h2>

<p>Autre source de confusion majeure : le <strong>Playground Xano</strong>.</p>

<ul>
    <li>Le Playground <strong>n'exÃ©cute pas</strong> les middlewares</li>
    <li>Les variables <code>middleware.*</code> n'y existent pas</li>
    <li>Toute tentative de lire une variable middleware renvoie une chaÃ®ne de texte brute</li>
</ul>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
Toujours tester les middlewares en <strong>Debug mode</strong> avec une vraie requÃªte HTTP, jamais uniquement dans le Playground qui ne reflÃ¨te pas le comportement rÃ©el.
</div>

<p>Ce comportement a donnÃ© l'impression que la logique n'Ã©tait pas injectÃ©e, alors qu'en rÃ©alitÃ© le middleware fonctionnaitâ€¦ mais sans jamais bloquer l'API.</p>

<h2>âœ… Confirmation externe</h2>

<p>Un test avec un collÃ¨gue a confirmÃ© le mÃªme comportement :</p>

<ul>
    <li>Middleware correctement configurÃ©</li>
    <li>Erreur visible dans le middleware</li>
    <li>Le endpoint continue quand mÃªme</li>
</ul>

<p>La conclusion Ã©tait irrÃ©futable :</p>

<pre><code>Les middlewares Xano ne peuvent pas Ãªtre utilisÃ©s
comme mÃ©canisme de sÃ©curitÃ©.</code></pre>

<h2>ğŸ”„ La solution : fonction check_role()</h2>

<p>Puisqu'un middleware ne peut :</p>

<ul>
    <li>ni bloquer la requÃªte</li>
    <li>ni renvoyer un HTTP 403 au client</li>
    <li>ni empÃªcher la Function Stack d'un endpoint de s'exÃ©cuter</li>
</ul>

<p>Il a fallu adopter une approche alternative.</p>

<h3>StratÃ©gie retenue</h3>

<p>Utiliser une <strong>fonction externe</strong> <code>check_role()</code> et appeler cette fonction au dÃ©but de chaque endpoint critique.</p>

<pre><code>DELETE /sessions/:id

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. call function check_role($auth.id)  â”‚
â”‚                                         â”‚
â”‚  2. if check_role() renvoie faux :      â”‚
â”‚     â†’ Return Response 403 "Forbidden"   â”‚
â”‚                                         â”‚
â”‚  3. sinon : continuer l'exÃ©cution       â”‚
â”‚     â†’ Delete record                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<h3>Avantages de cette approche</h3>

<ul>
    <li>La fonction peut faire une vÃ©rification stricte</li>
    <li>L'endpoint peut renvoyer des codes HTTP rÃ©els (403, 401â€¦)</li>
    <li>La sÃ©curitÃ© est centralisÃ©e, testable et fiable</li>
    <li>Aucun contournement possible</li>
</ul>

<div class="callout callout-advanced">
ğŸ”¬ <strong>Pour aller plus loin</strong><br>
Pour une sÃ©curitÃ© multi-niveaux, crÃ©ez des fonctions spÃ©cialisÃ©es : <code>check_role_admin()</code>, <code>check_role_repairer()</code>, <code>check_is_owner()</code>â€¦ Chaque fonction encapsule sa propre logique de vÃ©rification et peut Ãªtre rÃ©utilisÃ©e sur plusieurs endpoints.
</div>

<p>Cette mÃ©thode est, en rÃ©alitÃ©, <strong>la seule maniÃ¨re robuste</strong> d'implÃ©menter une sÃ©curitÃ© verticale dans Xano.</p>

<h2>ğŸ“Š Comparatif : Middleware vs Fonction</h2>

<table>
    <thead>
        <tr>
            <th>CritÃ¨re</th>
            <th>Middleware Xano</th>
            <th>Fonction check_role()</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Peut bloquer l'endpoint</td>
            <td>Non</td>
            <td>Oui</td>
        </tr>
        <tr>
            <td>Peut renvoyer HTTP 403</td>
            <td>Non</td>
            <td>Oui</td>
        </tr>
        <tr>
            <td>Testable dans Playground</td>
            <td>Non</td>
            <td>Oui</td>
        </tr>
        <tr>
            <td>Comportement prÃ©visible</td>
            <td>Non</td>
            <td>Oui</td>
        </tr>
        <tr>
            <td>AdaptÃ© Ã  la sÃ©curitÃ©</td>
            <td>Non</td>
            <td>Oui</td>
        </tr>
    </tbody>
</table>

<h2>ğŸ“ Enseignements pour les dÃ©veloppeurs Xano</h2>

<ul>
    <li>Les middlewares servent Ã  <strong>transformer et enrichir</strong> les donnÃ©es, pas Ã  filtrer des accÃ¨s</li>
    <li>La documentation peut prÃªter Ã  confusion â€” elle parle d'erreurs middleware, mais jamais d'interruption d'API</li>
    <li>Un test en Debug est <strong>indispensable</strong> pour comprendre le flow rÃ©el</li>
    <li>La sÃ©curitÃ© doit <strong>toujours</strong> Ãªtre implÃ©mentÃ©e dans l'endpoint lui-mÃªme, jamais dans un middleware</li>
</ul>

<div class="summary">
ğŸ“Œ <strong>Ã€ retenir :</strong>
<ul>
    <li>Les middlewares Xano ne bloquent <strong>jamais</strong> l'exÃ©cution d'un endpoint</li>
    <li>Pour la sÃ©curitÃ© par rÃ´le, utiliser une <strong>fonction dÃ©diÃ©e</strong> (ex: <code>check_role()</code>)</li>
    <li>Appeler cette fonction en <strong>dÃ©but de stack</strong> de chaque endpoint sensible</li>
    <li>Utiliser <code>Return Response 403</code> en cas d'Ã©chec de vÃ©rification</li>
    <li>Toujours tester en <strong>Debug mode</strong>, pas dans le Playground</li>
</ul>
</div>

<h2>ğŸ”— Liens utiles</h2>

<ul>
    <li><a href="#" data-article="../articles/xano/authentification-session-cookie-vs-jwt.html">Authentification : Session Cookie vs JWT</a> â€” Pour comprendre les mÃ©canismes d'authentification dans Xano</li>
    <li><a href="https://docs.xano.com/building-backend/function-stack/middlewares" target="_blank">Documentation officielle Xano â€” Middlewares</a></li>
</ul>
