<h1>Filtrer des sessions sans r√©servations : la solution avec LEFT JOIN et IS NULL</h1>

<p><strong>Dans cet article, je vais expliquer comment r√©cup√©rer toutes les sessions qui ne sont pas r√©serv√©es dans Xano, en utilisant LEFT JOIN et IS NULL. Je vais aussi montrer pourquoi les m√©thodes "√©videntes" (NOT IN, filtres classiques) ne fonctionnent pas et comment contourner les limitations de Xano.</strong></p>

<!-- Metadata block -->
<div class="metadata">
    <p>üè∑Ô∏è <strong>Cat√©gorie:</strong> Xano</p>
    <p>üéØ <strong>Niveau:</strong> Avanc√©</p>
    <p>üîç <strong>Mots-cl√©s:</strong> LEFT JOIN, IS NULL, Filtres WHERE, NOT IN, Query All Records, Debugging Xano, JOINs multiples, Xano AI</p>
    <p>üìÖ <strong>Mise √† jour:</strong> 16/11/2025</p>
    <p>‚è±Ô∏è <strong>Temps pass√©:</strong> 3 heures</p>
    <p>‚öôÔ∏è <strong>Stack:</strong> Xano</p>
</div>

<!-- TL;DR -->
<div class="tldr">
‚úÖ <strong>TL;DR :</strong>
Pour filtrer les sessions sans r√©servations dans Xano, utilisez un LEFT JOIN sur <code>reservation</code> avec les filtres de dates directement dans le JOIN, puis ajoutez un WHERE <code>$db.reservation.id == null</code>. Cette m√©thode √©vite les erreurs "Invalid value for param" et les comportements inattendus des filtres appliqu√©s apr√®s le JOIN.
</div>

<h2>ü§î Probl√®me rencontr√©</h2>

<p><strong>Objectif :</strong> R√©cup√©rer toutes les sessions d'un r√©parateur qui ne sont pas r√©serv√©es.</p>

<p>En SQL classique, c'est trivial :</p>

<pre><code>SELECT * FROM session
WHERE session.id NOT IN (
  SELECT session FROM reservation
)</code></pre>

<p>Ou encore :</p>

<pre><code>SELECT * FROM session
LEFT JOIN reservation ON session.id = reservation.session
WHERE reservation.id IS NULL</code></pre>

<p><strong>Sympt√¥mes rencontr√©s dans Xano :</strong></p>
<ul>
    <li>‚ùå Erreur <code>Invalid value for param: "session.id"</code> avec l'op√©rateur NOT IN</li>
    <li>‚ùå LEFT JOIN retourne des r√©sultats vides ou incomplets</li>
    <li>‚ùå Les filtres de dates "√©crasent" les lignes NULL g√©n√©r√©es par le LEFT JOIN</li>
    <li>‚ùå Les tentatives de transformation de listes (variables, pluck) compliquent inutilement le code</li>
    <li>‚ùå Xano AI d√©truit l'endpoint en modifiant les steps et inputs</li>
</ul>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Attention : Xano AI peut aggraver le probl√®me</strong><br>
Xano AI a tendance √† supprimer vos inputs, modifier vos steps, et restructurer vos endpoints sans demander. Si vous l'utilisez, v√©rifiez TOUJOURS que vos inputs et filtres sont encore pr√©sents apr√®s son intervention. Dans ce cas pr√©cis, Xano AI a "pulv√©ris√©" l'API au lieu d'aider.
</div>

<h2>üîç Explication : Pourquoi les m√©thodes "√©videntes" ne marchent pas</h2>

<h3>‚ùå M√©thode 1 : NOT IN avec une colonne join√©e</h3>

<p>Vous essayez :</p>

<pre><code>WHERE $db.session.id NOT IN $db.reservation.session</code></pre>

<p><strong>Pourquoi √ßa √©choue :</strong></p>
<ul>
    <li>L'op√©rateur <code>NOT IN</code> attend une <strong>liste de valeurs</strong></li>
    <li>Dans Xano, <code>$db.reservation.session</code> n'est pas une liste, mais une <strong>colonne d'une table join√©e</strong></li>
    <li>Xano renvoie : <code>Invalid value for param: "session.id"</code></li>
</ul>

<div class="callout callout-tip">
‚ú® <strong>Astuce : Diff√©rence entre liste et colonne</strong><br>
Une <strong>liste</strong> dans Xano est un tableau de valeurs (par exemple : <code>[1, 2, 3]</code>). Une <strong>colonne join√©e</strong> est un champ qui existe dans chaque ligne du r√©sultat du JOIN. NOT IN ne peut pas travailler avec une colonne, uniquement avec une liste.
</div>

<h3>‚ùå M√©thode 2 : LEFT JOIN + filtres de dates apr√®s le JOIN</h3>

<p>Vous essayez :</p>

<pre><code>LEFT JOIN reservation ON session.id = reservation.session
WHERE session.start_date <= $input.end_date
  AND session.end_date >= $input.start_date
  AND reservation.id IS NULL</code></pre>

<p><strong>Pourquoi √ßa √©choue :</strong></p>
<ul>
    <li>Le LEFT JOIN g√©n√®re correctement des lignes avec <code>reservation.id = NULL</code> pour les sessions non r√©serv√©es</li>
    <li><strong>Mais</strong> : les filtres de dates appliqu√©s <strong>apr√®s</strong> le JOIN √©liminent ces lignes NULL</li>
    <li>R√©sultat : m√™me les sessions non r√©serv√©es n'apparaissent pas comme NULL</li>
</ul>

<p><strong>Ordre d'ex√©cution SQL (simplifi√©) :</strong></p>

<pre><code>1. FROM session
2. LEFT JOIN reservation ‚Üí g√©n√®re NULL pour sessions sans r√©servations
3. WHERE session.start_date <= ... ‚Üí filtre les lignes, y compris celles avec NULL
   ‚ö†Ô∏è Si une session non r√©serv√©e ne correspond pas aux filtres de dates,
      elle est √©limin√©e avant m√™me qu'on puisse tester IS NULL</code></pre>

<h3>‚ùå M√©thode 3 : Variables et transformations de listes</h3>

<p>Vous pourriez essayer de :</p>
<ol>
    <li>Cr√©er une variable contenant la liste des IDs de sessions r√©serv√©es</li>
    <li>Utiliser une fonction de transformation (pluck, map, etc.)</li>
    <li>Appliquer NOT IN sur cette variable</li>
</ol>

<p><strong>Pourquoi c'est trop compliqu√© :</strong></p>
<ul>
    <li>Certaines versions de Xano n'ont pas le bloc <code>Pluck</code></li>
    <li>Les fonctions de transformation varient selon les versions</li>
    <li>√áa ajoute des √©tapes inutiles pour un probl√®me simple</li>
    <li>Moins maintenable et moins lisible</li>
</ul>

<div class="callout callout-advanced">
üî¨ <strong>Pour aller plus loin : Pourquoi Xano n'a pas NOT IN simplifi√©</strong><br>
Dans un SQL classique, <code>NOT IN (SELECT ...)</code> est une sous-requ√™te. Xano ne supporte pas nativement les sous-requ√™tes dans ses filtres WHERE. C'est pourquoi il faut contourner avec des JOINs et des tests de NULL. C'est une limitation de l'abstraction visuelle de Xano, qui privil√©gie les JOINs explicites.
</div>

<h2>‚úÖ La solution qui fonctionne : LEFT JOIN avec filtres dans le JOIN</h2>

<h3>üéØ Principe de la solution</h3>

<p>La cl√© est de <strong>placer les filtres de dates DANS le JOIN</strong> plut√¥t que dans le WHERE. Cela permet de :</p>

<ol>
    <li>Pr√©server les lignes NULL g√©n√©r√©es par le LEFT JOIN</li>
    <li>Appliquer les conditions de dates au bon moment</li>
    <li>Utiliser un simple <code>WHERE reservation.id IS NULL</code> pour exclure les sessions r√©serv√©es</li>
</ol>

<h3>üìã Configuration dans Xano Query All Records</h3>

<p><strong>√âtape 1Ô∏è‚É£ : LEFT JOIN sur <code>session</code> avec conditions de dates</strong></p>

<p>Dans votre Query All Records, configurez le JOIN sur <code>session</code> :</p>

<pre><code>LEFT JOIN session
ON session.repairer = $input.repairer_id
AND session.start_date <= $input.end_date
AND session.end_date >= $input.start_date</code></pre>

<p><strong>Points cl√©s :</strong></p>
<ul>
    <li>Les filtres de dates sont dans le <code>ON</code>, pas dans le <code>WHERE</code></li>
    <li>Cela garantit que le LEFT JOIN ne sera pas "annul√©" par les filtres</li>
</ul>

<p><strong>√âtape 2Ô∏è‚É£ : LEFT JOIN sur <code>reservation</code></strong></p>

<pre><code>LEFT JOIN reservation
ON reservation.session = session.id</code></pre>

<p><strong>Explication :</strong></p>
<ul>
    <li>Pour chaque session, Xano cherche une r√©servation correspondante</li>
    <li>Si aucune r√©servation n'existe, <code>reservation.id</code> sera <code>NULL</code></li>
</ul>

<p><strong>√âtape 3Ô∏è‚É£ : Filtre WHERE sur <code>reservation.id</code></strong></p>

<pre><code>WHERE $db.reservation.id == null</code></pre>

<p><strong>R√©sultat :</strong></p>
<ul>
    <li>‚úÖ Toutes les sessions <strong>sans r√©servations</strong> sont retourn√©es</li>
    <li>‚úÖ Toutes les sessions <strong>avec r√©servations</strong> sont exclues</li>
    <li>‚úÖ Les filtres de dates sont respect√©s</li>
    <li>‚úÖ Pas besoin de variables ni de transformations</li>
</ul>

<div class="callout callout-tip">
‚ú® <strong>Astuce : La diff√©rence entre ON et WHERE</strong><br>
<ul>
    <li><strong>ON</strong> : Conditions appliqu√©es <strong>pendant</strong> le JOIN. Les lignes qui ne matchent pas restent dans le r√©sultat avec NULL (LEFT JOIN).</li>
    <li><strong>WHERE</strong> : Conditions appliqu√©es <strong>apr√®s</strong> le JOIN. Les lignes qui ne matchent pas sont √©limin√©es compl√®tement.</li>
</ul>
Pour un LEFT JOIN, si vous voulez garder les NULL, mettez vos conditions dans le ON.
</div>

<h2>üß∞ Exemple concret</h2>

<h3>Contexte</h3>

<p>Vous avez :</p>
<ul>
    <li>Une table <code>session</code> avec des sessions de r√©paration</li>
    <li>Une table <code>reservation</code> avec une foreign key vers <code>session</code></li>
    <li>Vous voulez r√©cup√©rer les sessions d'un r√©parateur entre deux dates, mais <strong>uniquement celles qui ne sont pas r√©serv√©es</strong></li>
</ul>

<h3>Structure des tables</h3>

<pre><code>session
‚îú‚îÄ‚îÄ id
‚îú‚îÄ‚îÄ repairer (foreign key ‚Üí repairer.id)
‚îú‚îÄ‚îÄ start_date
‚îú‚îÄ‚îÄ end_date
‚îî‚îÄ‚îÄ ...

reservation
‚îú‚îÄ‚îÄ id
‚îú‚îÄ‚îÄ session (foreign key ‚Üí session.id)
‚îî‚îÄ‚îÄ ...</code></pre>

<h3>Configuration Xano</h3>

<p><strong>Inputs de l'endpoint :</strong></p>

<pre><code>{
  "repairer_id": 42,
  "start_date": "2025-11-01",
  "end_date": "2025-11-30"
}</code></pre>

<p><strong>Query All Records configuration :</strong></p>

<pre><code>Table: session

LEFT JOIN reservation
  ON reservation.session == $db.session.id

WHERE:
  AND [
    $db.session.repairer == $input.repairer_id,
    $db.session.start_date <= $input.end_date,
    $db.session.end_date >= $input.start_date,
    $db.reservation.id == null
  ]</code></pre>

<h3>R√©sultat attendu</h3>

<p>API retourne :</p>

<pre><code>[
  {
    "id": 101,
    "repairer": 42,
    "start_date": "2025-11-05",
    "end_date": "2025-11-05",
    "reservation": null  ‚Üê Pas de r√©servation
  },
  {
    "id": 103,
    "repairer": 42,
    "start_date": "2025-11-12",
    "end_date": "2025-11-12",
    "reservation": null  ‚Üê Pas de r√©servation
  }
]</code></pre>

<p>Les sessions avec r√©servations (session 102, par exemple) sont <strong>exclues</strong> du r√©sultat.</p>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Attention : Ordre des JOINs</strong><br>
L'ordre des JOINs peut affecter les performances. Dans ce cas, faites d'abord le JOIN sur <code>session</code> (avec vos filtres de dates et repairer) pour r√©duire le nombre de lignes, puis le JOIN sur <code>reservation</code>. Cela √©vite de charger toutes les r√©servations de la base.
</div>

<h2>üß† Pourquoi cette solution marche (et les autres non)</h2>

<table>
    <thead>
        <tr>
            <th>M√©thode</th>
            <th>Probl√®me</th>
            <th>Solution finale</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>NOT IN avec colonne</td>
            <td>NOT IN attend une liste, pas une colonne join√©e</td>
            <td>Utilise IS NULL au lieu de NOT IN</td>
        </tr>
        <tr>
            <td>LEFT JOIN + WHERE dates</td>
            <td>WHERE √©limine les lignes NULL avant le test IS NULL</td>
            <td>Met les filtres de dates dans le ON du JOIN</td>
        </tr>
        <tr>
            <td>Variables + transformations</td>
            <td>Trop complexe, d√©pend de la version Xano</td>
            <td>Utilise SQL pur avec LEFT JOIN</td>
        </tr>
    </tbody>
</table>

<p><strong>Cette solution est robuste parce que :</strong></p>

<ol>
    <li>Les filtres de dates sont dans le JOIN <code>session</code> ‚Üí emp√™che le LEFT JOIN d'√™tre annul√©</li>
    <li>LEFT JOIN sur <code>reservation</code> ‚Üí g√©n√®re NULL quand il n'y a pas de r√©servation</li>
    <li>Filtrer sur <code>reservation.id IS NULL</code> ‚Üí logique SQL classique pour trouver les lignes sans correspondance</li>
</ol>

<div class="callout callout-advanced">
üî¨ <strong>Pour aller plus loin : LEFT JOIN vs INNER JOIN</strong><br>
<ul>
    <li><strong>INNER JOIN</strong> : Ne retourne que les lignes qui ont une correspondance dans les deux tables. Si vous faites INNER JOIN reservation, vous n'aurez QUE les sessions r√©serv√©es.</li>
    <li><strong>LEFT JOIN</strong> : Retourne TOUTES les lignes de la table de gauche (session), m√™me si aucune correspondance n'existe dans la table de droite (reservation). Les colonnes de reservation seront NULL pour ces lignes.</li>
</ul>
C'est pourquoi LEFT JOIN + IS NULL est la technique standard pour trouver "les √©l√©ments A qui n'ont pas de correspondance dans B".
</div>

<!-- Final summary -->
<div class="summary">
üìå <strong>√Ä retenir :</strong>
<ul>
  <li><strong>NOT IN</strong> ne fonctionne pas avec une colonne join√©e dans Xano, uniquement avec une liste</li>
  <li>Les filtres appliqu√©s dans le <strong>WHERE</strong> apr√®s un LEFT JOIN √©liminent les lignes NULL</li>
  <li>La solution : mettre les filtres de dates <strong>dans le ON du JOIN</strong>, puis utiliser <strong>WHERE reservation.id IS NULL</strong></li>
  <li>LEFT JOIN + IS NULL est la technique SQL standard pour "trouver A sans B"</li>
  <li>Xano AI peut d√©truire vos endpoints ‚Äî v√©rifiez toujours vos inputs et steps apr√®s son intervention</li>
</ul>
</div>

<h2>üß† Quiz rapide</h2>

<details>
    <summary><strong>Question 1 :</strong> Pourquoi <code>NOT IN</code> ne fonctionne pas avec <code>$db.reservation.session</code> dans Xano ?</summary>
    <p><strong>R√©ponse :</strong> Parce que <code>NOT IN</code> attend une <strong>liste de valeurs</strong> (par exemple <code>[1, 2, 3]</code>), mais <code>$db.reservation.session</code> est une <strong>colonne join√©e</strong>, pas une liste. Xano renvoie donc une erreur <code>Invalid value for param</code>.</p>
</details>

<details>
    <summary><strong>Question 2 :</strong> Quelle est la diff√©rence entre mettre un filtre dans le <code>ON</code> d'un LEFT JOIN et dans le <code>WHERE</code> ?</summary>
    <p><strong>R√©ponse :</strong></p>
    <ul>
        <li><strong>ON</strong> : Condition appliqu√©e <strong>pendant</strong> le JOIN. Les lignes qui ne matchent pas restent dans le r√©sultat avec NULL (pour un LEFT JOIN).</li>
        <li><strong>WHERE</strong> : Condition appliqu√©e <strong>apr√®s</strong> le JOIN. Les lignes qui ne matchent pas sont compl√®tement √©limin√©es du r√©sultat.</li>
    </ul>
    <p>Pour un LEFT JOIN o√π vous voulez garder les NULL, mettez vos conditions dans le ON.</p>
</details>

<details>
    <summary><strong>Question 3 :</strong> Pourquoi utilise-t-on <code>LEFT JOIN</code> plut√¥t que <code>INNER JOIN</code> pour trouver les sessions sans r√©servations ?</summary>
    <p><strong>R√©ponse :</strong> Avec un <code>INNER JOIN</code>, seules les sessions qui ont une r√©servation seraient retourn√©es. Le <code>LEFT JOIN</code> retourne <strong>toutes</strong> les sessions, m√™me celles sans r√©servation (avec <code>reservation = NULL</code>). On peut ensuite filtrer sur <code>IS NULL</code> pour garder uniquement celles sans r√©servation.</p>
</details>

<h2>üîó Liens utiles</h2>

<ul>
    <li><a href="https://docs.xano.com/working-with-your-database/query-all-records" target="_blank">Documentation Xano : Query All Records</a></li>
    <li><a href="https://docs.xano.com/working-with-your-database/joins" target="_blank">Documentation Xano : JOINs</a></li>
    <li>Article connexe : <a href="#" data-article="../articles/xano/filtrage-par-date-jointures-recouvrement.html">Filtrer par date avec des jointures : r√©soudre le probl√®me de recouvrement de p√©riodes dans Xano</a></li>
    <li>Article connexe : <a href="#" data-article="../articles/xano/filtrer-sessions-par-utilisateur-api-dynamique.html">Filtrer des sessions par utilisateur avec une API dynamique dans Xano</a></li>
</ul>
