<h1>Xano + WeWeb : Comment filtrer des sessions par utilisateur et par date avec une seule API dynamique</h1>

<p><strong>Comprendre pourquoi votre API renvoie toujours les mÃªmes rÃ©sultats et comment identifier la bonne table source pour filtrer par utilisateur.</strong></p>

<!-- Metadata block -->
<div class="metadata">
    <p>ğŸ·ï¸ <strong>CatÃ©gorie:</strong> Xano</p>
    <p>ğŸ¯ <strong>Niveau:</strong> IntermÃ©diaire</p>
    <p>ğŸ” <strong>Mots-clÃ©s:</strong> Filtrage utilisateur, API dynamique, Relations tables, reservation vs session, Query All Records, Filtres conditionnels, WeWeb integration, user_id</p>
    <p>ğŸ“… <strong>Mise Ã  jour:</strong> 27/10/2025</p>
    <p>â±ï¸ <strong>Temps passÃ©:</strong> 1-2 heures</p>
    <p>âš™ï¸ <strong>Stack:</strong> Xano + WeWeb</p>
</div>

<!-- TL;DR -->
<div class="tldr">
âœ… <strong>TL;DR :</strong>
Pour filtrer des sessions par utilisateur, interrogez la table <strong>reservation</strong> (qui contient <code>user_id</code>) plutÃ´t que la table <strong>session</strong>. Utilisez un input dynamique (<code>filter</code>) pour gÃ©rer plusieurs cas (passÃ©, Ã  venir, annulÃ©) avec une seule API.
</div>

<h2>ğŸ¤” ProblÃ¨me rencontrÃ©</h2>

<p><strong>ğŸ¯ Objectif :</strong> CrÃ©er une seule API Xano permettant de rÃ©cupÃ©rer les sessions d'un utilisateur, filtrÃ©es selon trois cas :</p>

<ol>
    <li><strong>Sessions Ã  venir</strong> (upcoming)</li>
    <li><strong>Sessions passÃ©es</strong> (past)</li>
    <li><strong>Sessions annulÃ©es</strong> (cancelled)</li>
</ol>

<p>Cette API devait Ãªtre appelÃ©e depuis WeWeb avec un seul input dynamique (<code>filter</code>) et afficher les rÃ©sultats dans trois rÃ©pÃ©titeurs distincts.</p>

<p><strong>ğŸš¨ SymptÃ´me observÃ© :</strong></p>

<ul>
    <li>Peu importe le <code>user_id</code> envoyÃ© depuis WeWeb, l'API renvoyait <strong>toujours les 20 mÃªmes rÃ©sultats</strong></li>
    <li>Le filtrage par utilisateur ne fonctionnait pas</li>
    <li>Seuls les filtres par date semblaient s'appliquer</li>
</ul>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
Si votre API retourne toujours les mÃªmes rÃ©sultats peu importe les paramÃ¨tres, c'est souvent le signe que vous interrogez la <strong>mauvaise table source</strong> !
</div>

<h2>ğŸ” Analyse du problÃ¨me</h2>

<h3>âŒ L'approche initiale (incorrecte)</h3>

<p>La requÃªte Ã©tait Ã©crite sur la table <code>session</code>, en essayant de filtrer par utilisateur via une jointure :</p>

<pre><code>Table principale : session
Filtres tentÃ©s : user_id, dates, status
RÃ©sultat : Impossible de filtrer par utilisateur</code></pre>

<h3>ğŸ” La cause racine</h3>

<p><strong>Erreur logique :</strong></p>
<ul>
    <li>La table <code>session</code> ne contient <strong>pas d'information sur l'utilisateur</strong></li>
    <li>C'est la table <code>reservation</code> qui relie un utilisateur (<code>reservation.user</code>) Ã  une session (<code>reservation.session</code>)</li>
</ul>

<p><strong>Conclusion :</strong> On ne peut pas filtrer correctement par <code>user_id</code> en interrogeant directement la table <code>session</code>.</p>

<h2>ğŸ” Explication simplifiÃ©e</h2>

<h3>ğŸ“š Analogie : chercher les livres empruntÃ©s par un lecteur</h3>

<p>Imaginons que vous gÃ©rez une bibliothÃ¨que :</p>

<ul>
    <li><strong>âŒ Mauvaise approche</strong> : Consulter la liste complÃ¨te des livres dans la bibliothÃ¨que
        <ul>
            <li>ProblÃ¨me : la liste des livres ne dit pas <strong>qui</strong> a empruntÃ© quoi</li>
            <li>Vous obtenez tous les livres, impossible de filtrer par lecteur</li>
        </ul>
    </li>
    <li><strong>âœ… Bonne approche</strong> : Consulter les fiches d'emprunt
        <ul>
            <li>Chaque fiche contient : le lecteur, le livre empruntÃ©, les dates</li>
            <li>Vous pouvez facilement filtrer par lecteur</li>
        </ul>
    </li>
</ul>

<h3>ğŸ—‚ï¸ Structure des donnÃ©es</h3>

<p>Voici la structure simplifiÃ©e des tables :</p>

<pre><code>user (utilisateur)
  â†“ fait des
reservation (rÃ©servations)
  â†“ pointe vers
session (crÃ©neaux de disponibilitÃ©)
</code></pre>

<table>
    <thead>
        <tr>
            <th>Table</th>
            <th>Contient</th>
            <th>UtilitÃ©</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>session</code></td>
            <td>CrÃ©neaux de disponibilitÃ© (dates, rÃ©parateur, catÃ©gorie)</td>
            <td>DÃ©finit <strong>quand</strong> un service est disponible</td>
        </tr>
        <tr>
            <td><code>reservation</code></td>
            <td>RÃ©servations faites par les utilisateurs (user_id, session_id, status)</td>
            <td>DÃ©finit <strong>qui</strong> a rÃ©servÃ© <strong>quoi</strong></td>
        </tr>
        <tr>
            <td><code>user</code></td>
            <td>Informations utilisateur (nom, email, etc.)</td>
            <td>Identifie <strong>qui</strong> fait les rÃ©servations</td>
        </tr>
    </tbody>
</table>

<div class="callout callout-tip">
âœ¨ <strong>RÃ¨gle d'or</strong><br>
Toujours partir de la table qui contient l'information principale pour votre filtre. Ici, vous voulez filtrer par <strong>utilisateur</strong>, donc partez de la table <code>reservation</code> qui contient <code>user_id</code>.
</div>

<h2>âŒ Solutions testÃ©es (et pourquoi elles n'ont pas fonctionnÃ©)</h2>

<table>
    <thead>
        <tr>
            <th>MÃ©thode</th>
            <th>RÃ©sultat</th>
            <th>Statut</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Filtrer directement sur la table <code>session</code></td>
            <td>Renvoie toutes les sessions, impossible de filtrer par utilisateur</td>
            <td>âŒ</td>
        </tr>
        <tr>
            <td>Ajout de JOIN manuels multiples (user, repairer, category)</td>
            <td>GÃ©nÃ¨re des doublons ou ignore le <code>user_id</code></td>
            <td>âŒ</td>
        </tr>
        <tr>
            <td>Filtrage par date uniquement</td>
            <td>Fonctionne pour les dates, mais ne rÃ¨gle pas le problÃ¨me utilisateur</td>
            <td>âš ï¸</td>
        </tr>
        <tr>
            <td>Filtrer via la table <code>reservation</code> + JOIN <code>session</code></td>
            <td>Filtre correctement par utilisateur ET par date</td>
            <td>âœ…</td>
        </tr>
    </tbody>
</table>

<h2>âœ… La solution dÃ©taillÃ©e</h2>

<h3>ğŸ¯ Ã‰tape 1 : Identifier la bonne table source</h3>

<p><strong>Table principale :</strong> <code>reservation</code></p>

<p><strong>Pourquoi ?</strong></p>
<ul>
    <li>Elle contient <code>user_id</code> â†’ permet de filtrer par utilisateur</li>
    <li>Elle contient <code>session_id</code> â†’ permet de rÃ©cupÃ©rer les dates via JOIN</li>
    <li>Elle contient <code>status</code> â†’ permet de filtrer par statut (annulÃ©, confirmÃ©, etc.)</li>
</ul>

<h3>ğŸ”— Ã‰tape 2 : Configurer le JOIN vers session</h3>

<p>Xano gÃ¨re automatiquement les relations si elles sont configurÃ©es dans la base de donnÃ©es :</p>

<pre><code>Table principale : reservation
JOIN automatique : reservation.session â†’ session
AccÃ¨s aux donnÃ©es : session.start_date, session.end_date</code></pre>

<h3>ğŸ¨ Ã‰tape 3 : Ajouter le filtre dynamique</h3>

<p><strong>Inputs de l'API :</strong></p>

<pre><code>{
  "user_id": 10,
  "date": "2025-10-27T00:00:00.000Z",
  "filter": "upcoming"  // valeurs possibles : "past", "upcoming", "cancelled"
}</code></pre>

<p><strong>Logique conditionnelle dans Xano :</strong></p>

<table>
    <thead>
        <tr>
            <th>Filter</th>
            <th>Condition appliquÃ©e</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>"past"</code></td>
            <td><code>session.end_date &lt; input.date</code></td>
            <td>Sessions dÃ©jÃ  terminÃ©es</td>
        </tr>
        <tr>
            <td><code>"upcoming"</code></td>
            <td><code>session.start_date &gt; input.date</code></td>
            <td>Sessions Ã  venir</td>
        </tr>
        <tr>
            <td><code>"cancelled"</code></td>
            <td><code>reservation.status == "annulÃ©"</code></td>
            <td>Sessions annulÃ©es</td>
        </tr>
    </tbody>
</table>

<h3>ğŸ› ï¸ RequÃªte Xano complÃ¨te (Query All Records)</h3>

<p><strong>Configuration de base :</strong></p>

<pre><code>{
  "table": "reservation",
  "where": {
    "and": [
      {
        "expression": "$db.reservation.user ==? $input.user_id"
      }
    ]
  }
}</code></pre>

<p><strong>Avec conditions dynamiques (utiliser Function Stack) :</strong></p>

<pre><code>// 1. Query All Records sur table "reservation"
// Filtre par user_id :
$db.reservation.user ==? $input.user_id

// 2. Condition IF pour appliquer le bon filtre :

IF $input.filter == "past"
  THEN Filter : $db.session.end_date &lt; $input.date

ELSE IF $input.filter == "upcoming"
  THEN Filter : $db.session.start_date &gt; $input.date

ELSE IF $input.filter == "cancelled"
  THEN Filter : $db.reservation.status == "annulÃ©"</code></pre>

<div class="callout callout-tip">
âœ¨ <strong>Astuce Xano</strong><br>
Utilisez un <strong>Function Stack</strong> avec des conditions IF pour gÃ©rer plusieurs cas de filtrage. C'est plus maintenable qu'avoir 3 APIs diffÃ©rentes !
</div>

<h2>ğŸ§° Exemple concret</h2>

<h3>ğŸ“Š Structure des tables (simplifiÃ©e)</h3>

<p><strong>Table : user</strong></p>
<pre><code>{
  "id": 10,
  "name": "Marie Dupont",
  "email": "marie@example.com"
}</code></pre>

<p><strong>Table : session</strong></p>
<pre><code>{
  "id": 45,
  "start_date": "2025-11-05T09:00:00.000Z",
  "end_date": "2025-11-05T17:00:00.000Z",
  "repairer_category_id": 12
}</code></pre>

<p><strong>Table : reservation</strong></p>
<pre><code>{
  "id": 789,
  "user": 10,           // FK vers user
  "session": 45,        // FK vers session
  "status": "confirmÃ©",
  "created_at": "2025-10-20T10:00:00.000Z"
}</code></pre>

<h3>ğŸ“¥ Exemple de requÃªte API</h3>

<p><strong>Input :</strong></p>
<pre><code>{
  "user_id": 10,
  "date": "2025-10-27T00:00:00.000Z",
  "filter": "upcoming"
}</code></pre>

<p><strong>Output attendu :</strong></p>
<pre><code>[
  {
    "id": 789,
    "user": {
      "id": 10,
      "name": "Marie Dupont"
    },
    "session": {
      "id": 45,
      "start_date": "2025-11-05T09:00:00.000Z",
      "end_date": "2025-11-05T17:00:00.000Z"
    },
    "status": "confirmÃ©"
  }
]</code></pre>

<h2>ğŸ”— IntÃ©gration WeWeb</h2>

<h3>ğŸ“¡ Configuration de la collection Xano</h3>

<p><strong>Ã‰tape 1 : CrÃ©er la collection</strong></p>
<ul>
    <li>Nom : <code>user_sessions</code></li>
    <li>Endpoint : votre API Xano (ex: <code>/get_user_sessions</code>)</li>
    <li>Mode : <strong>Query parameters</strong></li>
</ul>

<p><strong>Ã‰tape 2 : Configurer les paramÃ¨tres dynamiques</strong></p>
<ul>
    <li><code>user_id</code> : <code>getCurrentUser().id</code> (ou variable WeWeb)</li>
    <li><code>date</code> : <code>new Date()</code> (date du jour)</li>
    <li><code>filter</code> : valeur selon le rÃ©pÃ©titeur</li>
</ul>

<h3>ğŸ”„ Configuration des rÃ©pÃ©titeurs</h3>

<p><strong>RÃ©pÃ©titeur 1 : Sessions Ã  venir</strong></p>
<pre><code>Collection : user_sessions
ParamÃ¨tres :
  - user_id : getCurrentUser().id
  - date : new Date()
  - filter : "upcoming"</code></pre>

<p><strong>RÃ©pÃ©titeur 2 : Sessions passÃ©es</strong></p>
<pre><code>Collection : user_sessions
ParamÃ¨tres :
  - user_id : getCurrentUser().id
  - date : new Date()
  - filter : "past"</code></pre>

<p><strong>RÃ©pÃ©titeur 3 : Sessions annulÃ©es</strong></p>
<pre><code>Collection : user_sessions
ParamÃ¨tres :
  - user_id : getCurrentUser().id
  - date : new Date()
  - filter : "cancelled"</code></pre>

<div class="callout callout-advanced">
ğŸ”¬ <strong>Pour aller plus loin</strong><br>
Vous pouvez ajouter d'autres filtres combinÃ©s : par catÃ©gorie, par rÃ©parateur, par plage de dates personnalisÃ©e. L'architecture avec <code>filter</code> dynamique permet d'Ã©tendre facilement les fonctionnalitÃ©s sans multiplier les APIs.
</div>

<h2>ğŸš€ BÃ©nÃ©fices de cette approche</h2>

<ul>
    <li>âœ… <strong>API unique</strong>, facile Ã  maintenir</li>
    <li>âœ… <strong>CohÃ©rence des donnÃ©es</strong> : un seul endpoint pour 3 cas d'usage</li>
    <li>âœ… <strong>Performance optimisÃ©e</strong> : pas de requÃªtes multiples inutiles</li>
    <li>âœ… <strong>IntÃ©gration fluide</strong> cÃ´tÃ© WeWeb avec collections dynamiques</li>
    <li>âœ… <strong>Architecture Ã©volutive</strong> : facile d'ajouter de nouveaux filtres</li>
</ul>

<h2>ğŸ’¡ Lessons Learned</h2>

<div class="summary">
ğŸ“Œ <strong>LeÃ§ons Ã  retenir :</strong>
<ul>
  <li><strong>Partir de la bonne table</strong> : celle qui contient l'information principale pour votre filtre (ici, <code>user_id</code> dans <code>reservation</code>)</li>
  <li><strong>Une API dynamique > plusieurs APIs</strong> : utiliser un input <code>filter</code> pour gÃ©rer plusieurs cas</li>
  <li><strong>Tester progressivement</strong> : isoler chaque condition pour identifier les problÃ¨mes</li>
  <li><strong>Comprendre les relations</strong> : savoir quelle table contient quelle information Ã©vite des heures de debugging</li>
</ul>
</div>

<h2>ğŸ”— Liens utiles</h2>

<ul>
    <li><a href="https://docs.xano.com/working-with-your-database/database-tables/relationships" target="_blank">Documentation Xano : Relations entre tables</a></li>
    <li><a href="https://docs.xano.com/api-functions/queries" target="_blank">Documentation Xano : Query All Records</a></li>
    <li>Article connexe dans cette base : <em>Filtrer par date avec des jointures</em></li>
    <li>Article connexe : <em>Pourquoi mon API Xano retourne toujours les mÃªmes donnÃ©es ?</em></li>
</ul>

<h2>ğŸ§  Quiz rapide</h2>

<p><strong>Question :</strong> Pourquoi est-il prÃ©fÃ©rable de crÃ©er une seule API avec un paramÃ¨tre <code>filter</code> plutÃ´t que 3 APIs distinctes (une pour chaque cas) ?</p>

<details>
    <summary>âœ… Voir la rÃ©ponse</summary>
    <p><strong>RÃ©ponse :</strong></p>
    <ul>
        <li><strong>Maintenance simplifiÃ©e</strong> : un seul endpoint Ã  maintenir et dÃ©bugger</li>
        <li><strong>CohÃ©rence</strong> : la logique de filtrage utilisateur est centralisÃ©e</li>
        <li><strong>Performance</strong> : pas de duplication de code ni de requÃªtes redondantes</li>
        <li><strong>Ã‰volutivitÃ©</strong> : ajouter un nouveau filtre ne nÃ©cessite qu'une condition supplÃ©mentaire, pas une nouvelle API</li>
        <li><strong>Code plus propre</strong> : moins d'endpoints, architecture plus claire</li>
    </ul>
    <p>En gÃ©nÃ©ral, privilÃ©giez toujours la flexibilitÃ© et la rÃ©utilisabilitÃ© : une API dynamique bien conÃ§ue vaut mieux que plusieurs APIs statiques.</p>
</details>
