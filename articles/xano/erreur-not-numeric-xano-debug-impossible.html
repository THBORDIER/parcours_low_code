<h1>L'erreur "Not numeric" de Xano : quand l'outil empÃªche le debug</h1>

<p class="subtitle">Retour d'expÃ©rience sur 1 heure de debug face Ã  une erreur Xano sans message exploitable, causÃ©e par des Inputs table-driven Ã©valuÃ©s implicitement. Diagnostic technique d'une limitation structurelle de l'outil.</p>

<!-- Metadata block -->
<div class="metadata">
    <p>ğŸ·ï¸ <strong>CatÃ©gorie:</strong> Xano</p>
    <p>ğŸ¯ <strong>Niveau:</strong> AvancÃ©</p>
    <p>ğŸ” <strong>Mots-clÃ©s:</strong> Not numeric, db.edit, Inputs, table-driven, debugging, error handling, cast, integer, runtime errors, Xano limitations, implicit binding, type coercion</p>
    <p>ğŸ“… <strong>Mise Ã  jour:</strong> 21/01/2026</p>
    <p>â±ï¸ <strong>Temps passÃ©:</strong> ~1h de debug sans solution</p>
    <p>âš™ï¸ <strong>Stack utilisÃ©e:</strong> Xano</p>
</div>

<!-- TL;DR -->
<div class="tldr">
âœ… <strong>TL;DR :</strong>
L'erreur <code>Exception: Not numeric</code> de Xano peut survenir lors d'un <code>db.edit</code> mÃªme avec des donnÃ©es valides, Ã  cause d'<strong>Inputs table-driven Ã©valuÃ©s implicitement</strong>. Si un champ integer dans les Inputs est vide, mal typÃ© ou mal bindÃ©, Xano Ã©choue sans indiquer quel champ pose problÃ¨me. Cette limitation structurelle rend le debug quasiment impossible et peut bloquer un endpoint fonctionnel. Solutions : supprimer les Inputs table-driven, recrÃ©er l'endpoint avec variables intermÃ©diaires, ou contourner db.edit.
</div>

<h2>ğŸ¤” ProblÃ¨me initial</h2>

<p><strong>ğŸ›‘ Contexte :</strong></p>
<p>Je dÃ©veloppe une API sur Xano pour remplir automatiquement les informations client via l'API Sirene de l'INSEE. Voici le flux :</p>

<ol>
    <li>L'utilisateur entre un SIRET</li>
    <li>J'appelle une fonction <code>P10_SIREN</code> qui interroge l'API INSEE</li>
    <li>La fonction retourne un objet <code>$infosiren</code> avec tous les champs (nom, adresse, ville, etc.)</li>
    <li>Je veux utiliser <code>db.edit</code> pour mettre Ã  jour un enregistrement dans la table <code>P10_client</code></li>
</ol>

<p><strong>ğŸ’¥ Erreur systÃ©matique :</strong></p>

<pre><code>Exception: Not numeric.</code></pre>

<p>Cette erreur survient <strong>systÃ©matiquement</strong> dÃ¨s que j'essaie de faire un <code>db.edit</code>, peu importe :</p>
<ul>
    <li>âœ… <code>$infosiren</code> est valide (confirmÃ© par debug/outputs)</li>
    <li>âœ… Les champs non-ND sont accessibles</li>
    <li>âœ… Le payload est correct</li>
    <li>âœ… La fonction INSEE fonctionne parfaitement</li>
</ul>

<h2>ğŸ” Ce qui a Ã©tÃ© vÃ©rifiÃ© (tests exhaustifs)</h2>

<p>J'ai passÃ© environ <strong>1 heure</strong> Ã  tester toutes les hypothÃ¨ses possibles :</p>

<h3>âœ”ï¸ VÃ©rification de $infosiren</h3>

<ul>
    <li>âœ… Objet non vide</li>
    <li>âœ… Tous les champs accessibles (<code>$infosiren.SIRET</code>, <code>$infosiren.ville</code>, etc.)</li>
    <li>âœ… Pas de JSON mal formÃ©</li>
    <li>âœ… Pas de wrapper inexploitable</li>
    <li>âœ… Valeurs visibles dans les outputs de debug</li>
</ul>

<h3>âœ”ï¸ Tests de mapping db.edit</h3>

<p>J'ai testÃ© <strong>toutes les variations possibles</strong> de <code>db.edit</code> :</p>

<table>
    <thead>
        <tr>
            <th>Test</th>
            <th>Configuration</th>
            <th>RÃ©sultat</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>Ã‰dition par <code>id</code></td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>2</td>
            <td>Ã‰dition par <code>devis_id</code></td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>3</td>
            <td>Ã‰dition par <code>SIRET</code> (champ text)</td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>4</td>
            <td>Suppression complÃ¨te de <code>devis_id</code></td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>5</td>
            <td>Suppression de tous les champs numÃ©riques dans <code>data</code></td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>6</td>
            <td>Envoi explicite de <code>devis_id: 1</code></td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>7</td>
            <td>Cast avec <code>to_int</code></td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>8</td>
            <td>Sans cast</td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>9</td>
            <td>Avec concat adresse</td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>10</td>
            <td>Sans concat adresse</td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>11</td>
            <td>Inputs partiels (3 champs)</td>
            <td>âŒ Not numeric</td>
        </tr>
        <tr>
            <td>12</td>
            <td>Inputs complets (tous les champs)</td>
            <td>âŒ Not numeric</td>
        </tr>
    </tbody>
</table>

<p><strong>ğŸ‘‰ RÃ©sultat identique Ã  chaque fois : <code>Not numeric</code></strong></p>

<h3>âœ”ï¸ VÃ©rification du payload</h3>

<p>J'ai vÃ©rifiÃ© manuellement que le payload envoyÃ© Ã©tait correct :</p>

<pre><code>{
  "SIRET": "12345678901234",
  "nomEntreprise": "DEMO SARL",
  "ville": "LYON",
  "codepostal": "69001",
  "Nvoie": "42",
  "typevoie": "RUE",
  "nomvoie": "DE LA REPUBLIQUE"
}</code></pre>

<p>Aucun champ numÃ©rique problÃ©matique. Tout est valide.</p>

<h2>ğŸ¯ Cause rÃ©elle identifiÃ©e</h2>

<p>AprÃ¨s 1 heure de debug, voici la cause rÃ©elle :</p>

<div class="callout callout-warning">
âš ï¸ <strong>Le problÃ¨me ne vient PAS du code XanoScript, ni de $infosiren</strong><br>
Il vient de l'<strong>UI Inputs de Xano</strong> couplÃ©e Ã  <code>db.edit</code>.
</div>

<h3>Ce qui se passe rÃ©ellement dans Xano</h3>

<ol>
    <li>Vous utilisez les <strong>Inputs gÃ©nÃ©rÃ©s automatiquement</strong> Ã  partir de la table <code>P10_client</code></li>
    <li>Dans ces Inputs, il existe au moins un champ de type <code>integer</code> (par exemple : <code>devis_id</code>, <code>id</code>, etc.)</li>
    <li>Ce champ est <strong>Ã©valuÃ© par Xano au runtime</strong>, mÃªme si :
        <ul>
            <li>Il n'est pas utilisÃ© dans <code>data</code></li>
            <li>Il est absent du body de la requÃªte</li>
            <li>Vous ne le voulez pas</li>
        </ul>
    </li>
    <li>Si ce champ integer est :
        <ul>
            <li>Vide (<code>""</code>)</li>
            <li>Mal typÃ©</li>
            <li>Mal bindÃ©</li>
            <li>Ou simplement interprÃ©tÃ© comme <code>""</code> au runtime</li>
        </ul>
    </li>
    <li>ğŸ‘‰ <strong>Xano tente de le caster en integer â†’ <code>Not numeric</code></strong></li>
</ol>

<div class="callout callout-warning">
âš ï¸ <strong>Point critique</strong><br>
L'erreur est levÃ©e <strong>avant</strong> que vous puissiez contrÃ´ler le flux. Xano :
<ul>
    <li>âŒ Ne donne <strong>aucun nom de champ fautif</strong></li>
    <li>âŒ Ne donne <strong>aucune trace exploitable</strong></li>
    <li>âŒ EmpÃªche tout <strong>debug rationnel</strong></li>
</ul>
</div>

<h2>ğŸš§ Pourquoi vous Ãªtes bloquÃ©</h2>

<p>MalgrÃ© :</p>
<ul>
    <li>âœ… La suppression de <code>devis_id</code> dans <code>data</code></li>
    <li>âœ… Le passage par <code>SIRET</code> (champ text) pour identifier l'enregistrement</li>
    <li>âœ… Un payload valide</li>
    <li>âœ… Des variables visibles et correctes</li>
</ul>

<p><strong>ğŸ‘‰ Xano continue d'Ã©valuer silencieusement les Inputs table-driven, et Ã©choue sans vous dire pourquoi.</strong></p>

<p>Vous Ãªtes donc bloquÃ© <strong>non pas par votre code</strong>, mais par :</p>
<ul>
    <li>âŒ Le moteur interne de Xano</li>
    <li>âŒ Son binding implicite</li>
    <li>âŒ Son absence totale de diagnostics exploitables</li>
</ul>

<p>Vous passez 1 heure Ã  tourner en rond sans pouvoir isoler le champ fautif, parce que <strong>l'outil ne vous laisse pas le contrÃ´ler</strong>.</p>

<h2>âŒ Limitations structurelles de Xano</h2>

<p>Ce problÃ¨me met en Ã©vidence des limitations graves de Xano :</p>

<table>
    <thead>
        <tr>
            <th>Limitation</th>
            <th>Impact</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>âŒ Inputs implicites impossibles Ã  neutraliser</td>
            <td>Xano Ã©value des champs que vous ne voulez pas utiliser</td>
        </tr>
        <tr>
            <td>âŒ Cast automatique non contrÃ´lable</td>
            <td>Impossible de dÃ©sactiver la coercition de type</td>
        </tr>
        <tr>
            <td>âŒ Erreurs gÃ©nÃ©riques inutiles</td>
            <td><code>Not numeric</code> sans indication du champ</td>
        </tr>
        <tr>
            <td>âŒ Aucune indication du champ fautif</td>
            <td>Debug par Ã©limination aveugle</td>
        </tr>
        <tr>
            <td>âŒ db.edit non dÃ©terministe en debug</td>
            <td>Impossible de comprendre pourquoi Ã§a Ã©choue</td>
        </tr>
        <tr>
            <td>âŒ Couplage dangereux UI â†” runtime</td>
            <td>L'UI gÃ©nÃ¨re du code implicite non maÃ®trisable</td>
        </tr>
        <tr>
            <td>âŒ Impossible d'isoler une erreur</td>
            <td>Il faut supprimer la moitiÃ© de l'endpoint pour tester</td>
        </tr>
    </tbody>
</table>

<div class="callout callout-warning">
âš ï¸ <strong>En clair</strong><br>
Xano empÃªche le debug fin, ce qui est <strong>rÃ©dhibitoire</strong> dÃ¨s qu'on sort d'un CRUD trivial.
</div>

<h2>âœ… Solutions de contournement</h2>

<p>Si vous Ãªtes confrontÃ© Ã  ce problÃ¨me, voici les solutions possibles :</p>

<h3>Solution 1 : Supprimer les Inputs table-driven</h3>

<ol>
    <li>Au lieu d'utiliser les Inputs gÃ©nÃ©rÃ©s automatiquement Ã  partir de la table</li>
    <li>CrÃ©ez des <strong>Inputs manuels</strong> avec uniquement les champs dont vous avez besoin</li>
    <li>DÃ©finissez explicitement le type de chaque input (text, integer, etc.)</li>
    <li>Ne crÃ©ez pas d'input pour les champs que vous ne voulez pas gÃ©rer</li>
</ol>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
Si vous n'avez besoin que de 3 champs (nomEntreprise, ville, codepostal), ne crÃ©ez que ces 3 Inputs. Xano n'essaiera pas de caster des champs qui n'existent pas.
</div>

<h3>Solution 2 : Endpoint minimaliste avec variables intermÃ©diaires</h3>

<p>CrÃ©ez un nouvel endpoint from scratch :</p>

<pre><code>// Input manuel (pas table-driven)
input {
  text SIRET
}

// Appeler la fonction
var $infosiren {
  value = function.P10_SIREN($input.SIRET)
}

// Variables intermÃ©diaires pour chaque champ
var $nom { value = $infosiren.nomEntreprise }
var $ville { value = $infosiren.ville }
var $cp { value = $infosiren.codepostal }

// db.edit avec query explicite
db.edit {
  table = "P10_client"
  query {
    SIRET = $input.SIRET
  }
  data {
    nomEntreprise = $nom
    ville = $ville
    codepostal = $cp
  }
}</code></pre>

<p>Cette approche Ã©vite les Inputs implicites et donne un contrÃ´le total sur les types.</p>

<h3>Solution 3 : Utiliser db.query + db.update sÃ©parÃ©ment</h3>

<p>Au lieu de <code>db.edit</code> (qui combine query + update), sÃ©parez les opÃ©rations :</p>

<pre><code>// 1. Trouver l'enregistrement
var $client {
  value = db.query {
    table = "P10_client"
    filter {
      SIRET = $input.SIRET
    }
  }|first
}

// 2. Mettre Ã  jour explicitement
db.update {
  table = "P10_client"
  id = $client.id
  data {
    nomEntreprise = $infosiren.nomEntreprise
    ville = $infosiren.ville
    codepostal = $infosiren.codepostal
  }
}</code></pre>

<h3>Solution 4 : Contourner db.edit avec un addon Query</h3>

<p>Si vous Ãªtes vraiment bloquÃ©, utilisez un <strong>addon Query</strong> avec du SQL brut :</p>

<pre><code>addon.query {
  sql = `UPDATE P10_client
         SET nomEntreprise = :nom, ville = :ville, codepostal = :cp
         WHERE SIRET = :siret`
  params {
    nom = $infosiren.nomEntreprise
    ville = $infosiren.ville
    cp = $infosiren.codepostal
    siret = $input.SIRET
  }
}</code></pre>

<p>Cette approche bypasse complÃ¨tement le systÃ¨me d'Inputs et de casting de Xano.</p>

<h2>ğŸ§ª Exemple de diagnostic</h2>

<p>Pour identifier quel Input pose problÃ¨me, procÃ©dez par Ã©limination :</p>

<ol>
    <li>Dupliquez votre endpoint</li>
    <li>Supprimez <strong>tous les Inputs</strong> sauf un</li>
    <li>Testez</li>
    <li>Si Ã§a marche, ce n'est pas cet Input â†’ ajoutez-en un autre</li>
    <li>Si Ã§a Ã©choue avec <code>Not numeric</code> â†’ c'est cet Input qui pose problÃ¨me</li>
    <li>VÃ©rifiez son type, sa valeur par dÃ©faut, son binding</li>
</ol>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
Cette mÃ©thode est fastidieuse et peut prendre 30-60 minutes. C'est exactement le problÃ¨me : Xano devrait vous dire <strong>quel champ</strong> pose problÃ¨me, au lieu de vous forcer Ã  dÃ©bugger Ã  l'aveugle.
</div>

<!-- Final summary -->
<div class="summary">
ğŸ“Œ <strong>Ã€ retenir :</strong>
<ul>
  <li><code>Exception: Not numeric</code> est souvent causÃ© par des <strong>Inputs table-driven Ã©valuÃ©s implicitement</strong></li>
  <li>Xano Ã©value tous les Inputs, mÃªme ceux non utilisÃ©s dans <code>data</code></li>
  <li>Si un champ integer est vide ou mal typÃ©, Xano Ã©choue sans indiquer lequel</li>
  <li>L'erreur survient <strong>avant</strong> votre code â†’ impossible Ã  dÃ©bugger proprement</li>
  <li>Solutions : supprimer les Inputs table-driven, crÃ©er des Inputs manuels, ou contourner db.edit</li>
  <li>Cette limitation est <strong>structurelle</strong> : Xano couple trop fortement l'UI et le runtime</li>
  <li>Pour du debug fin ou des flux complexes, cette limitation est rÃ©dhibitoire</li>
</ul>
</div>

<h2>ğŸ’­ RÃ©flexion sur les limites du low-code</h2>

<p>Ce problÃ¨me illustre une limite fondamentale des plateformes low-code comme Xano :</p>

<blockquote>
<strong>"Quand l'outil marche, tout va vite. Quand l'outil bloque, vous Ãªtes mains nouÃ©es."</strong>
</blockquote>

<p>En code traditionnel (Node.js, Python, PHP), une erreur <code>TypeError: Expected number, got string</code> vous donne :</p>
<ul>
    <li>âœ… Le nom de la variable fautive</li>
    <li>âœ… Le numÃ©ro de ligne</li>
    <li>âœ… La stack trace complÃ¨te</li>
    <li>âœ… La possibilitÃ© de logger, breakpoint, inspecter</li>
</ul>

<p>Avec Xano :</p>
<ul>
    <li>âŒ Erreur gÃ©nÃ©rique</li>
    <li>âŒ Aucune trace</li>
    <li>âŒ Impossible de logger finement</li>
    <li>âŒ Debug par Ã©limination aveugle</li>
</ul>

<p><strong>ğŸ‘‰ Cette asymÃ©trie de contrÃ´le est le prix du low-code.</strong></p>

<p>Sur des CRUD simples, Xano est imbattable en rapiditÃ©. Mais dÃ¨s qu'on sort du cadre (API externe, logique complexe, debug fin), les limitations deviennent bloquantes.</p>

<h2>ğŸ”— Articles connexes</h2>

<ul>
    <li><a href="../bonnes-pratiques/logique-metier-robuste-weweb-xano.html">Construire une logique mÃ©tier robuste avec WeWeb et Xano</a> â€“ Bonnes pratiques pour contourner les limites</li>
    <li><a href="realite-middlewares-xano.html">Comprendre la rÃ©alitÃ© des middlewares dans Xano</a> â€“ Autre limitation structurelle</li>
    <li><a href="../api/integration-api-sirene-insee.html">IntÃ©grer l'API Sirene de l'INSEE avec Xano</a> â€“ Contexte de ce problÃ¨me</li>
</ul>
