<h1>VÃ©rifier une signature Stripe dans Xano</h1>
<p class="subtitle">Ce qui ne marchait pas, pourquoi, et comment bien faire</p>

<div class="metadata">
    <p>ğŸ·ï¸ <strong>CatÃ©gorie:</strong> Xano</p>
    <p>ğŸ¯ <strong>Niveau:</strong> AvancÃ©</p>
    <p>ğŸ” <strong>Mots-clÃ©s:</strong> Stripe, Webhook, Signature, HMAC, SHA256, SÃ©curitÃ©, Verify Signature, Raw Body</p>
    <p>ğŸ“… <strong>Mise Ã  jour:</strong> 16/12/2025</p>
    <p>â±ï¸ <strong>Temps passÃ©:</strong> 2h30</p>
    <p>âš™ï¸ <strong>Stack:</strong> Xano + Stripe</p>
</div>

<div class="tldr">
âœ… <strong>TL;DR :</strong>
La fonction "Stripe: Verify Signature" de Xano Ã©choue si le body est modifiÃ© (mÃªme lÃ©gÃ¨rement). Il faut utiliser le raw body brut, reconstruire exactement le payload signÃ© (<code>t.raw_body</code>), et comparer le HMAC SHA-256 avec la valeur <code>v1</code> du header. Aucune transformation (unset, json_encode, trim) n'est tolÃ©rÃ©e.
</div>

<h2>ğŸ” Le contexte</h2>

<p>Stripe envoie des webhooks (notifications HTTP) Ã  ton backend pour t'informer d'Ã©vÃ©nements importants : paiement validÃ©, session terminÃ©e, etc.</p>

<p>Pour des raisons de sÃ©curitÃ©, <strong>Stripe signe chaque webhook</strong>. Ton backend doit vÃ©rifier cette signature pour Ãªtre sÃ»r que la requÃªte vient bien de Stripe et qu'elle n'a pas Ã©tÃ© modifiÃ©e.</p>

<p>Xano propose une fonction "Stripe: Verify Signature", mais dans la pratique :</p>

<ul>
    <li>elle est fragile,</li>
    <li>elle ne tolÃ¨re aucune modification du message,</li>
    <li>et elle n'explique pas clairement ce qui est attendu.</li>
</ul>

<p>RÃ©sultat : on se retrouve avec une fonction "low-code" qui ne fonctionne pas, sans message d'erreur exploitable.</p>

<h2>ğŸ“š Les notions de base (en clair)</h2>

<h3>1. Qu'est-ce qu'un header HTTP ?</h3>

<p>Un header est une information "technique" envoyÃ©e avec une requÃªte HTTP, mais sÃ©parÃ©e du contenu principal.</p>

<p><strong>Exemples :</strong></p>
<ul>
    <li><code>Content-Type</code> : indique le type de contenu envoyÃ©</li>
    <li><code>User-Agent</code> : qui envoie la requÃªte</li>
    <li><code>Stripe-Signature</code> : signature cryptographique fournie par Stripe</li>
</ul>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
Dans un webhook Stripe, la signature est dans un <strong>header</strong>, pas dans le body.
</div>

<h3>2. Qu'est-ce que le body (ou payload) ?</h3>

<p>Le body (ou payload) est le <strong>contenu principal</strong> de la requÃªte.</p>

<p>Dans un webhook Stripe, c'est un gros JSON qui dÃ©crit l'Ã©vÃ©nement :</p>
<ul>
    <li>type d'Ã©vÃ©nement</li>
    <li>identifiant de paiement</li>
    <li>montant</li>
    <li>client, etc.</li>
</ul>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
Pour Stripe, ce body doit Ãªtre utilisÃ© <strong>exactement tel qu'il est reÃ§u</strong>, caractÃ¨re par caractÃ¨re.
</div>

<h3>3. Qu'est-ce que la signature Stripe ?</h3>

<p>Stripe calcule une signature cryptographique Ã  partir de :</p>
<ul>
    <li>un timestamp (<code>t</code>)</li>
    <li>le body brut</li>
    <li>un secret partagÃ© (le webhook secret)</li>
</ul>

<p>La formule logique est :</p>

<pre><code>signature = HMAC_SHA256(
  secret,
  t + "." + raw_body
)</code></pre>

<div class="callout callout-advanced">
ğŸ”¬ <strong>Pour aller plus loin</strong><br>
Ton backend doit refaire exactement le mÃªme calcul, puis comparer le rÃ©sultat avec <code>v1</code> fourni dans le header <code>Stripe-Signature</code>.
</div>

<h2>âŒ Pourquoi la premiÃ¨re fonction ne fonctionnait PAS</h2>

<p>La fonction qui Ã©chouait cumulait plusieurs erreurs classiques mais fatales.</p>

<h3>1. Le body Ã©tait modifiÃ©</h3>

<ul>
    <li>utilisation de <code>unset</code></li>
    <li>utilisation de <code>json_encode</code></li>
    <li>utilisation de <code>trim</code></li>
</ul>

<p>MÃªme si le JSON "a l'air identique", un seul caractÃ¨re modifiÃ© (espace, saut de ligne, Ã©chappement) rend la signature invalide.</p>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
Stripe ne signe pas un JSON "logique", mais une <strong>suite d'octets</strong>.
</div>

<h3>2. Le payload signÃ© n'Ã©tait pas conforme</h3>

<p>Au lieu de signer :</p>
<pre><code>t + "." + raw_body</code></pre>

<p>La fonction signait une version transformÃ©e :</p>
<ul>
    <li>body encodÃ©</li>
    <li>point mal placÃ©</li>
    <li>concatÃ©nation ambiguÃ«</li>
</ul>

<p>Le calcul cryptographique ne pouvait donc jamais correspondre.</p>

<h3>3. MÃ©lange de sources pour le body</h3>

<p>La fonction utilisait Ã  la fois :</p>
<ul>
    <li><code>util.get_raw_input</code></li>
    <li>et un <code>raw_input</code> passÃ© en paramÃ¨tre</li>
</ul>

<p>Cela rend le comportement imprÃ©visible et difficile Ã  dÃ©boguer.</p>

<h2>âœ… Pourquoi la seconde fonction FONCTIONNE</h2>

<p>La fonction qui fonctionne respecte strictement les rÃ¨gles Stripe.</p>

<p><strong>Ce qu'elle fait correctement :</strong></p>

<ol>
    <li>Elle rÃ©cupÃ¨re le <strong>raw body brut</strong>
        <ul>
            <li>sans parsing</li>
            <li>sans nettoyage</li>
            <li>sans transformation</li>
        </ul>
    </li>
    <li>Elle extrait correctement les Ã©lÃ©ments du header <code>Stripe-Signature</code>
        <ul>
            <li><code>t</code> (timestamp)</li>
            <li><code>v1</code> (signature attendue)</li>
        </ul>
    </li>
    <li>Elle reconstruit le payload exactement comme Stripe :
        <pre><code>signed_payload = t + "." + raw_body</code></pre>
    </li>
    <li>Elle calcule le HMAC SHA-256 avec le bon secret</li>
    <li>Elle compare le rÃ©sultat avec <code>v1</code></li>
</ol>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
Les deux valeurs sont identiques â†’ la signature est valide
</div>

<h2>âœ”ï¸ Checklist de vÃ©rification</h2>

<p>Avant de dire "c'est bon", il faut vÃ©rifier :</p>

<table>
    <thead>
        <tr>
            <th>VÃ©rification</th>
            <th>Statut attendu</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Le body utilisÃ© pour la signature est le raw body, pas un JSON reconstruit</td>
            <td>âœ…</td>
        </tr>
        <tr>
            <td>Aucune fonction ne modifie le body (unset, json_encode, trim, etc.)</td>
            <td>âœ…</td>
        </tr>
        <tr>
            <td>Le payload signÃ© est exactement <code>t.raw_body</code></td>
            <td>âœ…</td>
        </tr>
        <tr>
            <td>La signature calculÃ©e est strictement identique Ã  <code>v1</code></td>
            <td>âœ…</td>
        </tr>
        <tr>
            <td>Le rÃ©sultat final est <code>true</code></td>
            <td>âœ…</td>
        </tr>
    </tbody>
</table>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
Si une seule de ces conditions n'est pas respectÃ©e, la vÃ©rification Ã©chouera.
</div>

<h2>ğŸ“Œ Ã€ retenir</h2>

<div class="summary">
ğŸ“Œ <strong>Ã€ retenir :</strong>
<ul>
    <li>Xano est "low-code", mais la vÃ©rification de signature Stripe n'est pas tolÃ©rante</li>
    <li>Le body doit Ãªtre utilisÃ© <strong>exactement tel qu'il est reÃ§u</strong> (raw body)</li>
    <li>Aucune transformation n'est acceptable : pas de <code>unset</code>, <code>json_encode</code>, <code>trim</code></li>
    <li>Le payload signÃ© doit Ãªtre <code>t + "." + raw_body</code> exactement</li>
    <li>La comparaison HMAC SHA-256 doit correspondre Ã  <code>v1</code> du header</li>
</ul>
</div>

<h2>ğŸ”— Liens utiles</h2>

<ul>
    <li><a href="https://stripe.com/docs/webhooks/signatures" target="_blank">Documentation Stripe : Webhook Signatures</a></li>
    <li><a href="#" data-article="../articles/xano/webhook-stripe-xano-brevo.html">Webhook Stripe â†’ Xano â†’ Email Brevo</a></li>
    <li><a href="#" data-article="../articles/xano/pourquoi-xano-webhooks-compliques.html">Pourquoi Xano rend les webhooks si compliquÃ©s</a></li>
    <li><a href="#" data-article="../articles/xano/flux-complet-weweb-xano-stripe-brevo.html">Flux complet : WeWeb â†’ Xano â†’ Stripe â†’ Brevo</a></li>
</ul>
