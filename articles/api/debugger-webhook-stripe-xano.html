<h1>D√©bugger un Webhook Stripe dans Xano ‚Äî Retour d'exp√©rience</h1>

<p class="subtitle">Comment r√©soudre les 3 erreurs les plus fr√©quentes lors de l'int√©gration d'un webhook Stripe dans Xano : √©chec de v√©rification de signature, body vide, et variables orphelines. Guide pratique avec code fonctionnel.</p>

<!-- Metadata block -->
<div class="metadata">
    <p>üè∑Ô∏è <strong>Cat√©gorie:</strong> API & Backend</p>
    <p>üéØ <strong>Niveau:</strong> Interm√©diaire</p>
    <p>üîç <strong>Mots-cl√©s:</strong> Webhook Stripe, Signature HMAC, json_decode, util.get_raw_input, checkout.session.completed, Debugging Xano, Stripe Webhook Secret, Encoding, Raw body</p>
    <p>üìÖ <strong>Mise √† jour:</strong> 03/02/2026</p>
    <p>‚è±Ô∏è <strong>Temps pass√©:</strong> 1h</p>
    <p>‚öôÔ∏è <strong>Stack utilis√©e:</strong> WeWeb (front) + Xano (back) + Stripe Checkout</p>
</div>

<!-- TL;DR -->
<div class="tldr">
‚úÖ <strong>TL;DR :</strong>
Lors de l'int√©gration d'un webhook Stripe dans Xano, trois erreurs critiques bloquent souvent l'ex√©cution : (1) <strong>la v√©rification de signature √©choue</strong> si on parse le body en JSON avant validation, (2) <strong><code>$body.type</code> est vide</strong> si on ne parse pas le raw body avec <code>json_decode</code>, (3) <strong>variables orphelines</strong> provoquent des erreurs fatales. Solution : utiliser <code>encoding = ""</code> pour garder le body brut, parser avec <code>json_decode</code> dans une variable s√©par√©e, et nettoyer tout code copi√© d'anciennes APIs.
</div>

<h2>ü§î Probl√®me rencontr√©</h2>

<p><strong>üõë Contexte m√©tier :</strong></p>
<p>Mise en place d'un syst√®me d'achat de cr√©dits via Stripe Checkout. Lorsqu'un utilisateur finalise un paiement, Stripe envoie un webhook √† Xano pour notifier l'√©v√©nement <code>checkout.session.completed</code>. L'API Xano doit alors :</p>

<ul>
    <li>Intercepter l'√©v√©nement webhook</li>
    <li>V√©rifier la signature HMAC de Stripe (s√©curit√©)</li>
    <li>Extraire les m√©tadonn√©es (<code>user_id</code>, <code>credit</code>)</li>
    <li>Cr√©diter le compte utilisateur en base de donn√©es</li>
</ul>

<p><strong>üí° Metadata envoy√©es par Stripe :</strong></p>
<pre><code>{
  "credit": "100",
  "user_id": "38"
}</code></pre>

<p><strong>üõë Sympt√¥mes rencontr√©s :</strong></p>
<ol>
    <li>La condition <code>if</code> n'est jamais valid√©e alors que les valeurs affich√©es sont identiques</li>
    <li>Apr√®s correction, <code>$body.type</code> retourne une cha√Æne vide</li>
    <li>Erreur fatale <code>Missing var entry: reservation1</code></li>
</ol>

<h2>üîç Comprendre les webhooks Stripe</h2>

<h3>Qu'est-ce qu'un webhook ?</h3>

<p>Un <strong>webhook</strong> est un appel HTTP automatique envoy√© par un service externe (ici Stripe) vers votre API lorsqu'un √©v√©nement se produit (paiement r√©ussi, abonnement annul√©, etc.).</p>

<p><strong>üß† Analogie :</strong> C'est comme une sonnette de porte. Au lieu de demander constamment "Y a-t-il quelqu'un ?" (polling), vous attendez que quelqu'un appuie sur la sonnette (webhook) pour agir.</p>

<p><strong>üìä Workflow complet :</strong></p>
<pre><code>User (WeWeb) ‚Üí [Paiement] ‚Üí Stripe Checkout
                                  ‚Üì
                          [checkout.session.completed]
                                  ‚Üì
                            Webhook Stripe
                                  ‚Üì
                            API Xano ‚Üí [V√©rif signature] ‚Üí [Cr√©dit user]</code></pre>

<h3>Pourquoi la v√©rification de signature ?</h3>

<p>Stripe signe chaque webhook avec un <strong>secret HMAC-SHA256</strong>. Cela garantit que :</p>
<ul>
    <li>‚úÖ Le webhook provient bien de Stripe (pas d'un attaquant)</li>
    <li>‚úÖ Le contenu n'a pas √©t√© modifi√© en transit</li>
    <li>‚úÖ Le webhook n'est pas rejou√© (protection contre les attaques replay)</li>
</ul>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Attention : body brut requis</strong><br>
La signature HMAC est calcul√©e sur le <strong>body brut exact</strong> (la cha√Æne de caract√®res telle que re√ßue). Si Xano parse le JSON avant la v√©rification, l'ordre des cl√©s ou le formatage peuvent changer, invalidant la signature. C'est la cause n¬∞1 d'√©chec des webhooks Stripe.
</div>

<h2>üß™ Probl√®me n¬∞1 ‚Äî La v√©rification de signature √©choue</h2>

<h3>Sympt√¥me</h3>

<p>La condition <code>if</code> n'est jamais valid√©e alors que <code>$body.type</code> contient bien <code>checkout.session.completed</code>. Le debug affiche :</p>

<pre><code>Condition IF non valid√©e.
Attendu: checkout.session.completed
Re√ßu: checkout.session.completed</code></pre>

<p>Les deux valeurs sont identiques, donc c'est la <strong>seconde condition</strong> qui √©choue : la v√©rification de signature.</p>

<h3>Cause</h3>

<p>L'API utilisait <code>encoding = "json"</code> dans <code>util.get_raw_input</code>, ce qui parse le body en objet JSON <strong>avant</strong> que la fonction de v√©rification de signature ne puisse lire le body brut.</p>

<p>Or, Stripe calcule le HMAC-SHA256 sur le <strong>body brut exact</strong>. Quand Xano re-s√©rialise l'objet avec <code>json_encode</code>, l'ordre des cl√©s ou le formatage peuvent diff√©rer, ce qui invalide la signature.</p>

<h3>Solution</h3>

<p>Passer <code>encoding = ""</code> (cha√Æne vide) pour r√©cup√©rer le body brut sans parsing :</p>

<pre><code>// ‚ùå Avant (body pars√© ‚Üí signature invalide)
util.get_raw_input {
  encoding = "json"
}

// ‚úÖ Apr√®s (body brut ‚Üí signature valide)
util.get_raw_input {
  encoding = ""
}</code></pre>

<div class="callout callout-tip">
‚ú® <strong>Astuce</strong><br>
Cette r√®gle s'applique √† <strong>tous les webhooks n√©cessitant une v√©rification HMAC</strong> (Stripe, GitHub, Shopify, etc.). Toujours utiliser <code>encoding = ""</code> pour garder le body intact.
</div>

<h2>üß™ Probl√®me n¬∞2 ‚Äî <code>$body.type</code> est vide apr√®s correction</h2>

<h3>Sympt√¥me</h3>

<p>Apr√®s le fix de la signature, <code>$body.type</code> retourne une cha√Æne vide. La condition <code>if</code> √©choue √† nouveau.</p>

<h3>Cause</h3>

<p>Avec <code>encoding = ""</code>, <code>$body</code> est une <strong>cha√Æne de caract√®res brute</strong>, pas un objet JSON. On ne peut donc pas acc√©der √† <code>$body.type</code> directement.</p>

<h3>Solution</h3>

<p>Parser le body brut avec <code>json_decode</code> dans une variable s√©par√©e :</p>

<pre><code>// 1. R√©cup√©rer le body BRUT (pour la signature)
util.get_raw_input {
  encoding = ""
  exclude_middleware = false
} as $raw_request

// 2. Parser en JSON dans une variable s√©par√©e
var $body {
  value = $raw_request|json_decode
}</code></pre>

<p><strong>‚úÖ R√©sultat :</strong></p>
<ul>
    <li>Le raw body (<code>$raw_request</code>) reste intact pour la v√©rification de signature</li>
    <li>L'objet JSON (<code>$body</code>) est exploitable pour acc√©der √† <code>$body.type</code>, <code>$body.data.object</code>, etc.</li>
</ul>

<div class="callout callout-advanced">
üî¨ <strong>Pour aller plus loin : le pipe <code>|json_decode</code></strong><br>
Xano utilise des pipes (<code>|</code>) pour cha√Æner des transformations. <code>$raw_request|json_decode</code> est √©quivalent √† <code>JSON.parse(rawRequest)</code> en JavaScript. Autres pipes utiles : <code>|to_int</code>, <code>|concat</code>, <code>|strlen</code>.
</div>

<h2>üß™ Probl√®me n¬∞3 ‚Äî <code>Missing var entry: reservation1</code></h2>

<h3>Sympt√¥me</h3>

<p>Erreur fatale au runtime :</p>

<pre><code>Missing var entry: reservation1</code></pre>

<h3>Cause</h3>

<p>Du code copi√© depuis une ancienne API (r√©servations) faisait r√©f√©rence √† <code>$reservation1</code>, une variable qui n'existe plus dans le nouveau contexte (cr√©dits).</p>

<div class="callout callout-warning">
‚ö†Ô∏è <strong>Danger du copier-coller</strong><br>
Lors du d√©veloppement rapide, il est tentant de copier une API existante et de la modifier. Mais les variables orphelines provoquent des erreurs fatales difficiles √† tracer. <strong>Toujours nettoyer le code copi√© ligne par ligne.</strong>
</div>

<h3>Solution</h3>

<p>Supprimer toutes les r√©f√©rences √† <code>$reservation1</code> et adapter le code au nouveau cas d'usage :</p>

<pre><code>// ‚ùå Ancien code (r√©servations)
db.edit reservation { ... } as $reservation1

// ‚úÖ Nouveau code (cr√©dits)
db.get user {
  field_name = "id"
  field_value = $body.data.object.metadata.user_id|to_int
} as $user

db.edit user {
  field_name = "id"
  field_value = $body.data.object.metadata.user_id|to_int
  data = {
    credit: ($user.credit|to_int) + ($body.data.object.metadata.credit|to_int)
  }
} as $user1</code></pre>

<h2>üß∞ Code final fonctionnel</h2>

<p>Voici le code complet de l'API webhook Stripe dans Xano :</p>

<pre><code>query "P10_stripe-webhook" verb=POST {
  api_group = "STRIPE"

  stack {
    var $debug_trace {
      value = []
    }

    // 1. R√©cup√©rer le body BRUT (essentiel pour la signature)
    util.get_raw_input {
      encoding = ""
      exclude_middleware = false
    } as $raw_request

    // 2. Parser en JSON pour exploiter les donn√©es
    var $body {
      value = $raw_request|json_decode
    }

    var $request_header {
      value = $env.$http_headers
    }

    // 3. V√©rifier la signature Stripe
    function.run "Stripe Custom Signature" {
      input = {
        http_headers: $request_header
        SECRET_KEY  : $env.stripe_key  // cl√© whsec_...
      }
    } as $func2

    // 4. Traiter si checkout r√©ussi + signature valide
    conditional {
      if (`$body.type` == "checkout.session.completed" && `$func2.result`) {
        db.get user {
          field_name = "id"
          field_value = $body.data.object.metadata.user_id|to_int
        } as $user

        db.edit user {
          field_name = "id"
          field_value = $body.data.object.metadata.user_id|to_int
          data = {
            credit: ($user.credit|to_int) + ($body.data.object.metadata.credit|to_int)
          }
        } as $user1
      }
    }
  }
}</code></pre>

<div class="callout callout-tip">
‚ú® <strong>Astuce : <code>$env.stripe_key</code></strong><br>
Ne jamais hardcoder la cl√© Stripe dans le code. Utiliser les <strong>Environment Variables</strong> de Xano pour stocker <code>stripe_key</code> = votre Webhook Signing Secret (<code>whsec_...</code>). Cela facilite la gestion multi-environnements (dev/prod) et am√©liore la s√©curit√©.
</div>

<h2>üß≠ Exemple de test avec Stripe CLI</h2>

<p>Pour tester votre webhook localement sans faire de vrais paiements :</p>

<ol>
    <li>Installer <a href="https://stripe.com/docs/stripe-cli" target="_blank" rel="noopener">Stripe CLI</a></li>
    <li>Se connecter : <code>stripe login</code></li>
    <li>√âcouter les webhooks : <code>stripe listen --forward-to https://votre-instance.xano.io/api:P10/stripe-webhook</code></li>
    <li>D√©clencher un √©v√©nement de test : <code>stripe trigger checkout.session.completed</code></li>
</ol>

<p>Vous verrez imm√©diatement si la signature est valid√©e et si les cr√©dits sont ajout√©s.</p>

<h2>üìã Tableau de diagnostic rapide</h2>

<table>
    <thead>
        <tr>
            <th>Sympt√¥me</th>
            <th>Cause probable</th>
            <th>Solution</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Signature invalide</td>
            <td><code>encoding = "json"</code></td>
            <td>Utiliser <code>encoding = ""</code></td>
        </tr>
        <tr>
            <td><code>$body.type</code> vide</td>
            <td>Body brut non pars√©</td>
            <td>Ajouter <code>var $body { value = $raw_request|json_decode }</code></td>
        </tr>
        <tr>
            <td>Missing var entry</td>
            <td>Variable orpheline (code copi√©)</td>
            <td>Nettoyer toutes les r√©f√©rences anciennes</td>
        </tr>
        <tr>
            <td>Webhook non re√ßu</td>
            <td>URL incorrecte dans Stripe Dashboard</td>
            <td>V√©rifier l'URL et le verbe (POST)</td>
        </tr>
        <tr>
            <td><code>whsec_...</code> invalide</td>
            <td>Cl√© API au lieu de Webhook Secret</td>
            <td>Utiliser la cl√© <strong>Webhook Signing Secret</strong> (Stripe Dashboard ‚Üí Webhooks)</td>
        </tr>
    </tbody>
</table>

<!-- Final summary -->
<div class="summary">
üìå <strong>√Ä retenir :</strong>
<ul>
  <li><strong>Toujours utiliser <code>encoding = ""</code></strong> pour les webhooks n√©cessitant une v√©rification de signature HMAC. Le body brut doit rester intact.</li>
  <li><strong>Parser ensuite avec <code>json_decode</code></strong> pour acc√©der aux propri√©t√©s de l'objet.</li>
  <li><strong><code>stripe_key</code> = la Webhook Signing Secret</strong> (<code>whsec_...</code>), pas la cl√© API (<code>sk_test_...</code>).</li>
  <li><strong>Ajouter des traces de debug</strong> (<code>$debug_trace</code>) √† chaque √©tape pour identifier rapidement o√π √ßa coince.</li>
  <li><strong>Nettoyer le code copi√©</strong> d'anciennes APIs ‚Äî les variables orphelines provoquent des erreurs fatales.</li>
  <li><strong>Tester avec Stripe CLI</strong> avant de d√©ployer en production pour valider la signature et le workflow complet.</li>
</ul>
</div>

<h2>üîó Liens utiles</h2>

<ul>
    <li><a href="https://stripe.com/docs/webhooks" target="_blank" rel="noopener">Documentation Stripe Webhooks</a></li>
    <li><a href="https://stripe.com/docs/webhooks/signatures" target="_blank" rel="noopener">V√©rification de signature Stripe</a></li>
    <li><a href="https://stripe.com/docs/stripe-cli" target="_blank" rel="noopener">Stripe CLI</a> ‚Äì Tester les webhooks localement</li>
    <li><a href="https://dashboard.stripe.com/webhooks" target="_blank" rel="noopener">Stripe Dashboard - Webhooks</a> ‚Äì Configurer vos endpoints</li>
</ul>
