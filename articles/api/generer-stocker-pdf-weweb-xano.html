<h1>GÃ©nÃ©rer et stocker un PDF depuis WeWeb vers Xano</h1>

<p class="subtitle">Dans cet article, je vais expliquer comment gÃ©nÃ©rer un PDF cÃ´tÃ© frontend avec html2canvas + jsPDF, puis l'envoyer et le stocker correctement dans Xano, en Ã©vitant les piÃ¨ges courants liÃ©s aux types de fichiers (Blob, File, File Resource, Attachment).</p>

<!-- Metadata block -->
<div class="metadata">
    <p>ğŸ·ï¸ <strong>CatÃ©gorie:</strong> API & Backend</p>
    <p>ğŸ¯ <strong>Niveau:</strong> AvancÃ©</p>
    <p>ğŸ” <strong>Mots-clÃ©s:</strong> Blob to File, Attachment Metadata, Storage Create Attachment, File Resource vs Attachment, Multipart Form Data, html2canvas, jsPDF</p>
    <p>ğŸ“… <strong>Mise Ã  jour:</strong> 31/01/2026</p>
    <p>â±ï¸ <strong>Temps passÃ©:</strong> 3-4 heures</p>
    <p>âš™ï¸ <strong>Stack:</strong> WeWeb + Xano</p>
</div>

<!-- TL;DR -->
<div class="tldr">
âœ… <strong>TL;DR :</strong>
Pour stocker un PDF gÃ©nÃ©rÃ© en frontend dans Xano, il faut respecter une chaÃ®ne de conversion stricte : <strong>Blob â†’ File â†’ File Resource â†’ Attachment â†’ DB</strong>. La clÃ© est d'utiliser <code>storage.create_attachment_metadata</code> pour convertir le file resource en attachment avant l'insertion en base.
</div>

<h2>ğŸ¤” ProblÃ¨me rencontrÃ©</h2>

<h3>ğŸ¯ Objectif initial</h3>

<ul>
    <li>GÃ©nÃ©rer un PDF cÃ´tÃ© frontend avec html2canvas + jsPDF (dans WeWeb)</li>
    <li>TÃ©lÃ©charger le PDF localement</li>
    <li>Envoyer le PDF Ã  Xano via une API</li>
    <li>Le stocker dans un champ <code>devis_pdf</code> d'un enregistrement existant</li>
    <li><strong>Sans crÃ©er de nouvel enregistrement inutile</strong></li>
</ul>

<h3>ğŸ›‘ SymptÃ´mes rencontrÃ©s</h3>

<p>MalgrÃ© un script JavaScript fonctionnel pour la gÃ©nÃ©ration du PDF, plusieurs problÃ¨mes apparaissaient :</p>

<ul>
    <li>Xano recevait <code>{}</code> ou une string chiffrÃ©e au lieu d'un fichier</li>
    <li>Le champ <code>devis_pdf.path</code> restait vide en base</li>
    <li><code>size = 0</code> dans les mÃ©tadonnÃ©es du fichier</li>
    <li>Messages d'erreur cryptiques : "Input requires attachment. Currently set to file resource."</li>
</ul>

<div class="callout callout-warning">
âš ï¸ <strong>Attention</strong><br>
Le problÃ¨me ne venait pas du script de gÃ©nÃ©ration PDF (qui fonctionnait parfaitement), mais de la <strong>chaÃ®ne de conversion entre les diffÃ©rents types de fichiers</strong> entre WeWeb et Xano.
</div>

<h2>ğŸ” Explication : comprendre les types de fichiers</h2>

<h3>ğŸ§  Les 4 types de fichiers Ã  distinguer</h3>

<p>Le parcours d'un fichier de WeWeb vers Xano passe par plusieurs formats. Chaque Ã©tape nÃ©cessite le bon type :</p>

<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>OÃ¹ ?</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Blob</strong></td>
            <td>JavaScript navigateur</td>
            <td>DonnÃ©es binaires brutes, non-sÃ©rialisables en JSON</td>
        </tr>
        <tr>
            <td><strong>File</strong></td>
            <td>JavaScript navigateur</td>
            <td>Extension de Blob avec nom et type MIME, exploitable par multipart</td>
        </tr>
        <tr>
            <td><strong>File Resource</strong></td>
            <td>Xano (entrÃ©e API)</td>
            <td>Fichier reÃ§u via multipart, temporaire, non stockable directement en DB</td>
        </tr>
        <tr>
            <td><strong>Attachment</strong></td>
            <td>Xano (base de donnÃ©es)</td>
            <td>MÃ©tadonnÃ©es de fichier stockÃ©es en base (path, size, mime, etc.)</td>
        </tr>
    </tbody>
</table>

<div class="callout callout-tip">
âœ¨ <strong>Astuce : l'analogie de la chaÃ®ne logistique</strong><br>
Imaginez un colis (PDF) qui doit voyager :
<ul>
    <li><strong>Blob</strong> = colis non emballÃ© (donnÃ©es brutes)</li>
    <li><strong>File</strong> = colis emballÃ© avec Ã©tiquette (nom + type)</li>
    <li><strong>File Resource</strong> = colis reÃ§u au centre de tri (temporaire)</li>
    <li><strong>Attachment</strong> = colis enregistrÃ© dans l'inventaire final (base de donnÃ©es)</li>
</ul>
Chaque Ã©tape nÃ©cessite une transformation spÃ©cifique.
</div>

<h3>ğŸ”„ La chaÃ®ne de conversion correcte</h3>

<pre><code>JavaScript (WeWeb)           Xano API                  Xano Database
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Blob                    â†’    (âŒ non exploitable)
    â†“
File                    â†’    File Resource         â†’   (âŒ type incompatible)
                                    â†“
                            Attachment Metadata   â†’   Attachment âœ…
</code></pre>

<h2>ğŸ§ª Solution Ã©tape par Ã©tape</h2>

<h3>Ã‰tape 1ï¸âƒ£ : GÃ©nÃ©rer le PDF et le convertir en File (WeWeb)</h3>

<p>Dans votre Custom JavaScript WeWeb, aprÃ¨s la gÃ©nÃ©ration du PDF avec jsPDF :</p>

<div class="callout callout-warning">
âš ï¸ <strong>Erreur frÃ©quente</strong><br>
Ne pas utiliser directement <code>pdf.save()</code> car cela tÃ©lÃ©charge uniquement le fichier sans le rendre exploitable par le workflow.
</div>

<pre><code>// âŒ Mauvais : tÃ©lÃ©charge uniquement
pdf.save("devis.pdf");

// âœ… Bon : rÃ©cupÃ©rer le Blob puis le convertir en File
const pdfBlob = pdf.output("blob");
const pdfFile = new File([pdfBlob], "devis.pdf", {
  type: "application/pdf"
});

return {
  pdf_blob: pdfFile,
  filename: "devis.pdf",
  mime: "application/pdf"
};
</code></pre>

<p><strong>Pourquoi ?</strong> WeWeb peut sÃ©rialiser un Blob en JSON (rÃ©sultat : <code>{}</code>), mais un <code>File</code> est correctement reconnu comme fichier uploadable.</p>

<h3>Ã‰tape 2ï¸âƒ£ : Configurer l'API WeWeb en multipart (WeWeb)</h3>

<p>Dans l'action API de votre workflow WeWeb :</p>

<ol>
    <li>CrÃ©er une action API POST vers votre endpoint Xano</li>
    <li><strong>Content Type</strong> : sÃ©lectionner <code>multipart/form-data</code></li>
    <li>Ajouter un champ <code>PDF</code> avec la formule : <code>pdf_blob</code> (retour du script JS)</li>
    <li>Ajouter <code>devis_id</code> (ID de l'enregistrement Ã  mettre Ã  jour)</li>
</ol>

<div class="callout callout-warning">
âš ï¸ <strong>Erreur frÃ©quente</strong><br>
Si vous laissez <code>Content-Type: application/json</code>, Xano recevra une string JWT ou <code>{}</code> au lieu du fichier.
</div>

<h3>Ã‰tape 3ï¸âƒ£ : Convertir File Resource en Attachment (Xano)</h3>

<p>Dans votre API Xano, voici la configuration correcte :</p>

<pre><code>// API : P10_devis/PDF
// Verb : POST

Input {
  file? PDF?
  int devis_id?
}

Stack {
  // ğŸ”‘ Ã‰tape clÃ© : convertir file resource en attachment
  storage.create_attachment_metadata {
    file_resource = $input.PDF
  } as $att

  // Mettre Ã  jour l'enregistrement existant
  db.edit P10_devis {
    field_name = "id"
    field_value = $input.devis_id
    data = { devis_pdf: $att }
  } as $result1
}

Response = $result1
</code></pre>

<div class="callout callout-tip">
âœ¨ <strong>Astuce</strong><br>
<code>storage.create_attachment_metadata</code> est la fonction magique qui transforme un <code>file resource</code> (temporaire) en <code>attachment</code> (stockable en base).
</div>

<h3>ğŸ”¬ Comprendre <code>storage.create_attachment_metadata</code></h3>

<p>Cette fonction Xano :</p>

<ul>
    <li>Prend un <code>file_resource</code> en entrÃ©e</li>
    <li>Stocke le fichier dans le storage Xano</li>
    <li>Retourne un objet <code>attachment</code> avec :
        <ul>
            <li><code>path</code> : chemin du fichier stockÃ©</li>
            <li><code>size</code> : taille en bytes</li>
            <li><code>mime</code> : type MIME</li>
            <li><code>name</code> : nom du fichier</li>
        </ul>
    </li>
</ul>

<h2>âŒ Fausses pistes Ã  Ã©viter</h2>

<h3>ğŸš« Tentatives incorrectes</h3>

<table>
    <thead>
        <tr>
            <th>Tentative</th>
            <th>Pourquoi Ã§a ne fonctionne pas</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Stocker directement <code>$input.PDF</code> dans la DB</td>
            <td>Type incompatible : file resource â‰  attachment</td>
        </tr>
        <tr>
            <td>Utiliser <code>Create File Resource</code></td>
            <td>Cette fonction crÃ©e un fichier depuis du texte/base64, pas depuis un upload</td>
        </tr>
        <tr>
            <td>Envoyer le fichier en JSON</td>
            <td>Les fichiers binaires ne peuvent pas Ãªtre sÃ©rialisÃ©s en JSON</td>
        </tr>
        <tr>
            <td>Forcer le <code>path</code> cÃ´tÃ© frontend</td>
            <td>Le path est gÃ©nÃ©rÃ© par Xano lors du stockage</td>
        </tr>
    </tbody>
</table>

<div class="callout callout-warning">
âš ï¸ <strong>PiÃ¨ge frÃ©quent : Create File Resource</strong><br>
La fonction <code>Create File Resource</code> de Xano accepte un paramÃ¨tre <code>filedata</code> de type <strong>text</strong>, pas <code>file resource</code>. Elle sert Ã  crÃ©er un fichier depuis une URL, du base64 ou du texte brut. Elle ne peut PAS traiter un fichier uploadÃ© via multipart.
</div>

<h2>ğŸ§­ Exemple concret : workflow complet</h2>

<h3>ScÃ©nario utilisateur</h3>

<p>Un utilisateur gÃ©nÃ¨re un devis, l'affiche Ã  l'Ã©cran, puis clique sur "TÃ©lÃ©charger et sauvegarder le PDF".</p>

<h3>Code JavaScript (WeWeb)</h3>

<pre><code>// Charger les librairies
const html2canvas = await import('https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/+esm');
const jsPDF = await import('https://cdn.jsdelivr.net/npm/jspdf@2.5.1/+esm');

// Capturer l'Ã©lÃ©ment HTML
const element = document.getElementById('devis-container');
const canvas = await html2canvas.default(element);

// GÃ©nÃ©rer le PDF
const pdf = new jsPDF.default();
const imgData = canvas.toDataURL('image/png');
pdf.addImage(imgData, 'PNG', 10, 10, 190, 0);

// âœ… Convertir en File
const pdfBlob = pdf.output("blob");
const pdfFile = new File([pdfBlob], "devis.pdf", {
  type: "application/pdf"
});

// TÃ©lÃ©charger localement
pdf.save("devis.pdf");

// Retourner pour le workflow
return {
  pdf_blob: pdfFile,
  filename: "devis.pdf"
};
</code></pre>

<h3>Configuration API WeWeb</h3>

<ul>
    <li><strong>URL</strong> : <code>https://votre-instance.xano.io/api:1/p10_devis/PDF</code></li>
    <li><strong>Method</strong> : POST</li>
    <li><strong>Content-Type</strong> : multipart/form-data</li>
    <li><strong>Body</strong> :
        <ul>
            <li><code>PDF</code> = <code>pdf_blob</code> (formule WeWeb)</li>
            <li><code>devis_id</code> = <code>123</code> (ID de l'enregistrement)</li>
        </ul>
    </li>
</ul>

<h3>API Xano</h3>

<pre><code>POST /p10_devis/PDF

Input:
  - PDF (file, optional)
  - devis_id (int, optional)

Stack:
  1. storage.create_attachment_metadata {
       file_resource: $input.PDF
     } â†’ $att

  2. db.edit P10_devis {
       field_name: "id"
       field_value: $input.devis_id
       data: { devis_pdf: $att }
     } â†’ $result

Response: $result
</code></pre>

<h3>âœ… RÃ©sultat en base</h3>

<pre><code>{
  "id": 123,
  "devis_pdf": {
    "path": "/uploads/2026/01/31/abc123.pdf",
    "size": 245678,
    "mime": "application/pdf",
    "name": "devis.pdf"
  }
}
</code></pre>

<h2>ğŸ“Œ Ã€ retenir</h2>

<div class="summary">
ğŸ“Œ <strong>Points clÃ©s :</strong>
<ul>
    <li><strong>Blob â‰  File â‰  File Resource â‰  Attachment</strong> : chaque type a son rÃ´le et son contexte</li>
    <li>Dans WeWeb : convertir le Blob en <code>File</code> avec <code>new File([blob], name, {type})</code></li>
    <li>Dans l'API WeWeb : toujours utiliser <code>multipart/form-data</code> pour les fichiers</li>
    <li>Dans Xano : utiliser <code>storage.create_attachment_metadata</code> pour convertir file resource â†’ attachment</li>
    <li>Ne JAMAIS utiliser <code>Create File Resource</code> pour traiter un upload multipart</li>
    <li>Toujours vÃ©rifier le type rÃ©el du champ en base (attachment vs file resource vs text)</li>
</ul>
</div>

<div class="callout callout-advanced">
ğŸ”¬ <strong>Pour aller plus loin</strong><br>
<ul>
    <li>GÃ©rer les erreurs de gÃ©nÃ©ration PDF (Ã©lÃ©ment non trouvÃ©, timeout)</li>
    <li>Compresser le PDF cÃ´tÃ© frontend avec <code>pdf.output("blob", {compress: true})</code></li>
    <li>Ajouter un watermark ou des mÃ©tadonnÃ©es PDF</li>
    <li>Versionner les PDFs (archiver l'ancien avant remplacement)</li>
    <li>ImplÃ©menter un systÃ¨me de signature Ã©lectronique sur le PDF</li>
</ul>
</div>

<h2>ğŸ“ Quiz rapide</h2>

<p><strong>ğŸ§  Question :</strong> Pourquoi ne peut-on pas stocker directement <code>$input.PDF</code> (file resource) dans un champ de type <code>attachment</code> ?</p>

<details>
    <summary>âœ… Voir la rÃ©ponse</summary>
    <p>Parce qu'un <code>file resource</code> est un fichier temporaire reÃ§u via l'API, tandis qu'un <code>attachment</code> est un objet contenant les mÃ©tadonnÃ©es d'un fichier stockÃ© (path, size, mime). Il faut utiliser <code>storage.create_attachment_metadata</code> pour effectuer la conversion et le stockage.</p>
</details>

<h2>ğŸ”— Ressources utiles</h2>

<ul>
    <li><a href="https://developer.mozilla.org/fr/docs/Web/API/Blob" target="_blank" rel="noopener">Documentation MDN : Blob</a></li>
    <li><a href="https://developer.mozilla.org/fr/docs/Web/API/File" target="_blank" rel="noopener">Documentation MDN : File</a></li>
    <li><a href="https://docs.xano.com/working-with-data/file-uploads" target="_blank" rel="noopener">Xano Docs : File Uploads</a></li>
    <li><a href="https://html2canvas.hertzen.com/" target="_blank" rel="noopener">html2canvas - Documentation officielle</a></li>
    <li><a href="https://github.com/parallax/jsPDF" target="_blank" rel="noopener">jsPDF - Repository GitHub</a></li>
    <li><a href="#" data-article="../articles/api/integration-weweb-xano.html">Article : IntÃ©gration WeWeb-Xano</a></li>
    <li><a href="#" data-article="../articles/weweb/generer-pdf-html2canvas-jspdf.html">Article : GÃ©nÃ©rer un PDF depuis WeWeb</a></li>
</ul>
